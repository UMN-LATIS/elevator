{"version":3,"sources":["mule-uploader.js"],"names":["mule_upload","settings","Uploader","u","this","input","file_input","file","chunk_size","MB","max_size","num_workers","key","bucket","host","access_key","content_type","acl","on_progress","on_chunk_progress","on_select","on_error","on_complete","on_init","on_start","on_chunk_uploaded","extra_params","ajax_base","accepted_extensions","set_state","onchange","e","force","get_state","files","upload_file","setTimeout","apply","debug","log","console","args","i","arguments","length","push","XHR","headers","method","xhr","XMLHttpRequest","load_callback","addEventListener","error_callback","state_change_callback","progress_callback","upload","timeout_callback","url","param_name","indexOf","encodeURIComponent","open","header","setRequestHeader","body","send","KB","GB","File","prototype","slice","webkitSlice","mozSlice","window","FileList","Blob","navigator","userAgent","lastModifiedDate","Date","size","alert","file_extension","name","split","pop","extensions_array","file_accepted","call","get_init_signature","signature","date","upload_id","get_all_signatures","load_file","list_parts","_loaded_chunks","_progress","_total_progress","_uploading_chunks","_chunks","authorization","handler","xml","target","responseXML","getElementsByTagName","textContent","x-amz-date","x-amz-acl","Authorization","Content-Type","Content-Disposition","_start_fired","get_total_progress","next_chunk","get_next_chunk","upload_chunk","upload_finished","finish_upload","chunk","get_chunk_uploading","set_chunk_uploading","get_chunk_signature","start","end","Math","min","last_progress_time","_intervals","is_chunk_loaded","readyState","DONE","status","error_handler","notify_chunk_uploaded","clearInterval","set_progress","get_chunk_size","set_chunk_finished","interval","setInterval","progress_handler","loaded","error_handled","error_arguments","check_already_uploaded","notify_upload_finished","abort","path","blob","timeout_handler","xhrs","_chunk_xhr","get_end_signature","responseText","parts","update_chunks","cancel","num_chunks","ceil","data","callback","part_marker","get_list_signature","xml_parts","part_number","parseInt","etag","is_truncated","new_parts","concat","response","JSON","parse","escape","collectionId","chunks","add_loaded_chunk","bytes_started","valueOf","_chunk_signatures","chunk_signatures","_list_signature","list_signature","_end_signature","end_signature","_delete_signature","delete_signature","inner_handler","x","_init_chunks","is_selected","_state","state","log_status","val","list","is_last_chunk","f"],"mappings":"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","file":"mule-uploader.js","sourcesContent":["/**\n * mule-upload.js\n *\n * Copyright 2012-2013, Gabriel Purcaru\n * Released under GPL License.\n * License: http://www.gnu.org/copyleft/gpl.html\n */\n\nfunction mule_upload(settings) {\n    var debug = true;\n\n    // custom logging function that prepends a text for easy identification;\n    // it is also toggled by the `debug` flag\n    var log = function() {};\n    if(debug && console && console.log) {\n        log = function() {\n            var args = [\"[MuleUploader]\"];\n            for(var i=0; i<arguments.length; i++) {\n                args.push(arguments[i]);\n            }\n            return console.log.apply(console, args);\n        };\n    }\n\n    // AJAX helper. It takes an object that contains load_callback, error_callback,\n    // url, method, headers, state_change_callback, progress_callback\n    var XHR = function(args) {\n        // the user may not pass any headers\n        args.headers = args.headers || {};\n\n        // if no method is given, default to GET\n        args.method = args.method || \"GET\";\n\n        var xhr = new XMLHttpRequest();\n        // set the \"load\" callback if given\n        if(args.load_callback && typeof args.load_callback == 'function') {\n            xhr.addEventListener(\"load\", args.load_callback, true);\n        }\n\n        // set the \"error\" callback if given\n        if(args.error_callback && typeof args.error_callback == 'function') {\n            xhr.addEventListener(\"error\", args.error_callback, true);\n        }\n\n        // set the \"readystatechange\" callback if given\n        if(args.state_change_callback && typeof args.state_change_callback == 'function') {\n            xhr.addEventListener(\"readystatechange\", args.state_change_callback);\n        }\n\n        // set the \"progress\" callback if given\n        if(args.progress_callback && typeof args.progress_callback == 'function') {\n            xhr.upload.addEventListener(\"progress\", args.progress_callback);\n        }\n\n        // set the \"timeout\" callback if given\n        if(args.timeout_callback && typeof args.timeout_callback == 'function') {\n            xhr.addEventListener('timeout', timeout_callback);\n        }\n\n        // adding extra params as needed\n        var url = args.url;\n        if(args.extra_params) {\n            for(param_name in args.extra_params) {\n                if(url.indexOf('?') !== -1) {\n                    url += \"&\";\n                } else {\n                    url += \"?\";\n                }\n\n                url += encodeURIComponent(param_name) + \"=\";\n                url += encodeURIComponent(args.extra_params[param_name]);\n            }\n        }\n\n        // open the xhr connection\n        xhr.open(args.method, url);\n\n        // set the headers\n        for(var header in args.headers) {\n            xhr.setRequestHeader(header, args.headers[header]);\n        }\n\n        // send the ajax call\n        if(args.body) {\n            xhr.send(args.body);\n        } else {\n            xhr.send();\n        }\n        return xhr;\n    };\n\n    // helper constants for more readable code\n    var KB = 1024;\n    var MB = 1024 * KB;\n    var GB = 1024 * MB;\n\n    // for new webkit browsers, the .slice() method is named .webkitSlice()\n    // similar for mozilla\n    File.prototype.slice = File.prototype.webkitSlice || File.prototype.mozSlice || File.prototype.slice;\n\n    // verify that the browser has the needed HTML5 capabilities\n    if(!(window.File && window.FileList && window.Blob)) {\n        return -1;\n    }\n    if(navigator.userAgent.indexOf(\"Firefox\") !== -1) {\n        try {\n            new Blob([\"something\"]);\n        } catch(e) {\n            return -1;\n        }\n    }\n    log(\"OK\");\n\n    function Uploader(settings) {\n        // `u` is often used as an alias for `this` to be used in nested closures\n        var u = this;\n\n        settings = settings || {};\n\n        // make the input element another possible setting\n        // in some cases (e.g. drag & drop) there is no input element\n        u.input = settings.file_input;\n        u.file  = settings.file;\n        // NOTE: For Amazon S3, the minimum chunk size is 5MB\n        // we are using 6 for safe measure. Note that the maximum number of chunks\n        // is 10,000, so for example, if the chunk size is 6MB, the maximum\n        // possible file size is 6MB * 10,000 = ~58GB\n        settings.chunk_size = settings.chunk_size || (6 * MB); // default 6MB\n        settings.max_size = settings.max_size || 50 * (1 << 30); // 5GB\n\n        // the number of parallel upload xhr's\n        settings.num_workers = settings.num_workers || 4;\n\n        // the S3 object key; I recommend to generate this dynamically (e.g.\n        // a random string) to avoid unwanted overwrites.\n        settings.key = settings.key || \"the_key\";\n\n        // the Amazon S3 bucket where you'll store the uploads\n        settings.bucket = settings.bucket;\n        settings.host = settings.host || \"http://\" + settings.bucket + \".s3.amazonaws.com\";\n\n        // the Amazon S3 access key. DO NOT give the AWS Secret code!\n        settings.access_key = settings.access_key;\n\n        // the Mime-Type of the content. You must match this with the backend value\n        // or you'll get an Invalid Signature error. If unsure about the\n        // mime type, use application/octet-stream\n        settings.content_type = settings.content_type || \"application/octet-stream\";\n\n\n        // acl can be set to:\n        // private\n        // public-read (* default)\n        // public-read-write\n        // authenticated-read\n        // bucket-owner-read\n        // bucket-owner-full-control\n        // log-delivery-write\n        settings.acl = settings.acl || 'private';\n\n        // various callbacks\n        settings.on_progress = settings.on_progress || function() {};\n        settings.on_chunk_progress = settings.on_chunk_progress || function() {};\n        settings.on_select = settings.on_select || function() {};\n        settings.on_error = settings.on_error || function() {};\n        settings.on_complete = settings.on_complete || function() {};\n        settings.on_init = settings.on_init || function() {};\n        settings.on_start = settings.on_start || function() {};\n        settings.on_chunk_uploaded = settings.on_chunk_uploaded || function() {};\n\n        // extra parameters to give to the backend\n        settings.extra_params = settings.extra_params || {};\n\n        // the location prefix of the uploader's backend\n        settings.ajax_base = settings.ajax_base || \"/uploadBackend/upload/\";\n\n        //extensions comma delimited without period (jpg,jpeg,png,gif)\n        settings.accepted_extensions = settings.accepted_extensions || \"\";\n\n        // set the values so that they can be used everywhere, as needed\n        u.settings = settings;\n\n        // the \"waiting\" state means the uploader is waiting for the user\n        // to select a file\n        u.set_state(\"waiting\");\n\n        if (u.input) {\n            u.input.onchange = function(e, force) {\n                // the `onchange` event may be triggered multiple times, so we\n                // must ensure that the callback is only executed the first time\n                if(u.get_state() != \"waiting\") {\n                    return false;\n                }\n\n                // the uploader doesn't support multiple uploads at this time,\n                // so we get the first file\n                var file = u.input.files[0];\n                u.upload_file(file, force);\n            };\n        }\n\n        // trigger the init event callback\n        setTimeout(function() {\n            u.settings.on_init.apply(u);\n        }, 100);\n    }\n\n    Uploader.prototype.upload_file = function(file, force) {\n        var u = this;\n        // the `onchange` event may be triggered multiple times, so we\n        // must ensure that the callback is only executed the first time\n        // also make sure the file is not already set.\n        if(u.get_state() != \"waiting\") {\n            return false;\n        }\n\n        if (file) {\n            u.file = file;\n        }\n\n        if (!u.file) {\n            return false;\n        }\n\n        // we use the lastModifiedDate, the file name and size to uniquely\n        // identify a file. There may be false positives and negatives,\n        // but the chance for a false positive is basically zero.\n        // some browsers don't report the last modified date, so we default\n        // to a blank date\n        u.file.lastModifiedDate = u.file.lastModifiedDate || new Date(0);\n\n        if(u.file.size > u.settings.max_size) {\n            alert(\"The maximum allowed file size is \" + (u.settings.max_size / GB)\n                  + \"GB. Please select another file.\");\n            return;\n        }\n\n        // check for accepted extensions, if applicable\n        if(u.settings.accepted_extensions) {\n            // get the file extension\n            var file_extension = file.name.split('.').pop();\n\n            // split the given extensions into an array\n            extensions_array = u.settings.accepted_extensions.split(',');\n\n            // and match the extension against the given extension list\n            var file_accepted = false;\n            for(var i=0; i<extensions_array.length; i++) {\n                if(file_extension == extensions_array[i]) {\n                    file_accepted = true;\n                    break;\n                }\n            }\n\n            // if the file is not accepted, notify the user and return\n            if(!file_accepted) {\n                alert(\"This file format is not accepted. Please use a file with an extension like '\"\n                    + u.settings.accepted_extensions);\n                return;\n            }\n        }\n\n        // initialize the file upload\n        // we need the `init` signature for this\n        u.settings.on_select.call(u, file);\n        u.get_init_signature(function(signature, date) {\n            if(!u.upload_id) {\n\n                u.upload_id = null;\n                this._loaded_chunks = null;\n                u._progress = null;\n                u._total_progress = null;\n                u._loaded_chunks = null;\n                u._uploading_chunks = null;\n                u._chunks = null;\n                // the backend doesn't report an older upload\n                var authorization = \"AWS \" + settings.access_key + \":\" + signature;\n                var handler = function(e) {\n                    // trigger the on_select event callback\n                    var xml = e.target.responseXML;\n\n                    // get the given upload id\n                    u.upload_id = xml.getElementsByTagName('UploadId')[0].textContent;\n\n                    // get all signatures, then initiate the file upload\n                    u.get_all_signatures(function() {\n                        u.load_file(file);\n                    });\n                };\n                XHR({\n                    method: \"POST\",\n                    url: settings.host + \"/\" + settings.key + \"?uploads\",\n                    load_callback: handler,\n                    error_callback: handler,\n                    headers: {\n                        \"x-amz-date\": date,\n                        \"x-amz-acl\": settings.acl,\n                        \"Authorization\": authorization,\n                        \"Content-Type\": u.settings.content_type,\n                        \"Content-Disposition\": \"attachment; filename=\" + u.file.name\n                    }\n                });\n            } else {\n                // resume a previus upload\n                if(!force) {\n                    // get the uploaded parts from S3\n                    u.list_parts(function() {\n                        // start the upload\n                        u.get_all_signatures(function() {\n                            u.load_file(file);\n                        });\n                    }, function() {\n                        // if it fails, re-initiate the upload, and force\n                        // it to start a new upload\n                        u.upload_id = null;\n                        this._loaded_chunks = null;\n                        u._progress = null;\n                        u._total_progress = null;\n                        u._loaded_chunks = null;\n                        u._uploading_chunks = null;\n                        u._chunks = null;\n                        return u.upload_file(file, true); // force reload\n                    });\n                } else {\n                    // force-start the upload\n                    u.get_all_signatures(function() {\n                        u.load_file(file);\n                    });\n                }\n            }\n        }, force);\n    };\n\n    // this initiates the file upload\n    Uploader.prototype.load_file = function(file) {\n        var u = this;\n\n        // we can't start the upload if we are waiting for user input\n        if(u.get_state() != \"waiting\") {\n            return;\n        }\n\n        // make sure we only trigger the start event once\n        if(!u._start_fired) {\n            // trigger the start event callback\n            u.settings.on_start.call(u, u.file);\n\n            // and also trigger a progress callback with 0%)\n            u.settings.on_progress.call(u, 0, u.file.size);\n            u._start_fired = true;\n        }\n\n        // from now on, we are \"processing\" the file upload\n        u.set_state(\"processing\");\n\n        // at this point we may have some chunks already uploaded,\n        // so we may trigger a progress callback with the reported progress\n        u.settings.on_progress.call(u, u.get_total_progress(), u.file.size);\n\n        // get the next chunk\n        var next_chunk = u.get_next_chunk();\n\n        if(next_chunk != -1) {\n            // and start uploading it\n            u.upload_chunk(next_chunk);\n        } else if(u.upload_finished()) {\n            // if we finished, trigger the upload finish sequence\n            log(\"All done; finish upload\");\n            u.finish_upload();\n        }\n\n        for(var i=0; i < u.settings.num_workers - 1; i++) {\n            next_chunk = u.get_next_chunk();\n            if(next_chunk !== -1) {\n                u.upload_chunk(next_chunk);\n            } else {\n                break;\n            }\n        }\n    };\n\n    // this uploads a single chunk to S3\n    Uploader.prototype.upload_chunk = function(chunk) {\n        var u = this;\n        // make sure we're in processing mode\n        if(u.get_state() != \"processing\") {\n            log(\"NOT processing; return\");\n            return;\n        }\n\n        // also make sure we're not already uploading this chunk\n        if(u.get_chunk_uploading(chunk)) {\n            log(\"Already Uploading\");\n            setTimeout(function() {\n                var next_chunk = u.get_next_chunk();\n                if(next_chunk !== -1) {\n                    u.get_all_signatures(function() {\n                        u.upload_chunk(u.get_next_chunk());\n                    });\n                }\n            }, 1000);\n            return;\n        } else {\n            // mark this chunk as uploading\n            u.set_chunk_uploading(chunk);\n        }\n        log(\"Uploading Chunk: \" + chunk);\n\n        // we need the chunk's upload signature to initiate the\n        // chunk upload. Note that we may already have the chunk signature at\n        // this point (e.g. given by get_all_signatures), but we can throw\n        // get_X_signature's around because ajax calls are only initiated\n        // if we don't already have the needed signatures.\n        u.get_chunk_signature(chunk, function(signature, date) {\n            var length = u.settings.chunk_size;\n\n            // get the start and end bytes for the needed chunk\n            var start = chunk * length;\n            var end = Math.min(start + length, u.file.size);\n\n            // we need the last progress time in order to detect hanging\n            // uploads\n            var last_progress_time = new Date();\n            u._intervals = u._intervals || {};\n\n            // if we already uploaded this chunk, get to the next one\n            // if there is no next chunk, finish the upload\n            if(u.is_chunk_loaded(chunk)) {\n                var next_chunk = u.get_next_chunk();\n                if(next_chunk != -1) {\n                    u.upload_chunk(next_chunk);\n                } else {\n                    if(u.upload_finished()) {\n                        log(\"No next chunk; finish upload\");\n                        u.finish_upload();\n                    }\n                }\n            }\n\n            // the \"readystatechange\" handler\n            var handler = function(e) {\n                // we care about the \"done\" event triggered while processing\n                if(e.target.readyState != this.DONE || u.get_state() != \"processing\") {\n                    log(e);\n                    return;\n                }\n\n                // if we don't receive a 2XX response, trigger an error\n                if(e.target.status / 100 != 2) {\n                    return error_handler();\n                }\n\n                // at this point, we know that this chunk finished uploading\n                log(\"Chunk uploaded: \" + chunk);\n\n                // notify the server of the uploaded chunk\n                u.notify_chunk_uploaded(chunk);\n\n                // and also trigger the chunk_uploaded callback\n                u.settings.on_chunk_uploaded.call(u, chunk);\n\n                // cancel the xhr watcher interval\n                clearInterval(u._intervals[chunk]);\n\n                // mark the chunk as finished\n                u.set_progress(chunk, u.get_chunk_size(chunk));\n                u.set_chunk_finished(chunk);\n                u.set_chunk_uploading(chunk, false);\n\n                // get next chunk; if we're out of chunks,\n                // finish the upload\n                var next_chunk = u.get_next_chunk();\n                if(next_chunk != -1) {\n                    u.upload_chunk(next_chunk);\n                } else if(u.upload_finished()) {\n                    log(\"Done\");\n                    u.finish_upload();\n                } else {\n                    var interval = setInterval(function() {\n                        var chunk = u.get_next_chunk();\n                        if(chunk != -1) {\n                            clearInterval(interval);\n                            u.upload_chunk(chunk);\n                        } else if(u.upload_finished()) {\n                            clearInterval(interval);\n                            u.finish_upload();\n                        }\n                    }, 1000);\n                }\n            };\n\n            // the upload progress handler\n            var progress_handler = function(e) {\n\n                // set the internal chunk's progress value to the reported amount\n                u.set_progress(chunk, e.loaded);\n                // trigger the progress event callback\n                u.settings.on_progress.call(u, u.get_total_progress(), u.file.size);\n\n                // update the last_progress_time for the watcher interval\n                last_progress_time = new Date();\n            };\n            var error_handled = false;\n            var error_handler = function() {\n                var error_arguments = arguments;\n                var xhr = this;\n                // the upload may have finished, so check for that\n                u.check_already_uploaded(function() {\n                    // if already uploaded\n                    u.set_state(\"finished\");\n\n                    u.notify_upload_finished();\n\n                    // trigger a final progress event callback, with 100%\n                    u.settings.on_progress.call(u, u.file.size, u.file.size);\n\n                    // also trigger the complete event callback\n                    u.settings.on_complete.call(u);\n                }, function() {\n                    // we have a genuine error\n\n                    log(\"Error: \");\n                    log(error_arguments);\n\n                    // make sure we don't handle the same error more than once\n                    if(error_handled) {\n                        return;\n                    }\n                    error_handled = true;\n\n                    // abort the chunk upload\n                    u.set_chunk_uploading(chunk, false);\n                    u.set_chunk_finished(chunk, false);\n                    u.set_progress(chunk, 0);\n                    log(\"Abort\");\n                    try {\n                        xhr.abort();\n                    } catch(e) {\n                        log(e);\n                    }\n\n                    log(\"Retry chunk: \" + chunk);\n\n                    // clear the watcher interval\n                    clearInterval(u._intervals[chunk]);\n\n                    // re-try the upload\n                    setTimeout(function() {\n                        if(u.get_state() == \"processing\") {\n                            // and proceed\n                            var next_chunk = u.get_next_chunk(chunk);\n                            if(next_chunk !== -1) {\n                                u.get_all_signatures(function() {\n                                    u.upload_chunk(u.get_next_chunk());\n                                });\n                            }\n                        }\n                    }, 1000);\n                });\n            };\n\n\n            // The chunk number is 0-indexed to simplify the calculations,\n            // but S3 requires 1-indexed part numbers\n            var path = \"/\" + u.settings.key;\n            path += \"?partNumber=\" + (chunk + 1) + \"&uploadId=\" + u.upload_id;\n            var method = \"PUT\";\n            var authorization = \"AWS \" + u.settings.access_key + \":\" + signature;\n            var blob = u.file.slice(start, end);\n\n            var xhr = XHR({\n                method: \"PUT\",\n                url: u.settings.host + path,\n                progress_callback: progress_handler,\n                state_change_callback: handler,\n                error_handler: error_handler,\n                timeout_handler: error_handler,\n                headers: {\n                    \"x-amz-date\": date,\n                    \"Authorization\": authorization,\n                    \"Content-Type\": u.settings.content_type,\n                    \"Content-Disposition\": \"attachment; filename=\" + u.file.name\n                },\n                body: blob\n            });\n\n            window.xhrs = window.xhrs || [];\n            window.xhrs.push(xhr);\n\n            u._chunk_xhr = u._chunk_xhr || [];\n            u._chunk_xhr.push(xhr);\n\n\n            // the watcher interval; it cancels the xhr if it times out\n            u._intervals[chunk] = setInterval(function() {\n                if(last_progress_time && (new Date() - last_progress_time) > 15000) { // 15s\n                    log(\"Chunk Failed; retry\");\n                    clearInterval(u._intervals[chunk]);\n                    if(u.get_state() == \"processing\") {\n                        xhr.abort();\n                        error_handler.call(xhr);\n                    }\n                }\n            }, 4000); // every 4s\n        });\n    };\n\n    // initiates the upload finish sequence\n    Uploader.prototype.finish_upload = function() {\n        var u = this;\n\n        // make sure it's not triggered when not processing (e.g. multiple times)\n        if(u.get_state() != \"processing\") {\n            return;\n        }\n\n        // change the upload's state\n        u.set_state(\"finishing\");\n\n        u.settings.on_progress.call(u, u.file.size, u.file.size); // 100% done.\n\n        // we need the ending signature to put the chunks together\n        this.get_end_signature(function(signature, date) {\n            var path = \"/\" + u.settings.key + \"?uploadId=\" + u.upload_id;\n            var method = \"POST\";\n            var authorization = \"AWS \" + u.settings.access_key + \":\" + signature;\n\n            var handler = function(e) {\n                // i.e. if it's a 2XX response\n                if(e.target.status / 100 == 2) {\n                    log(\"Finished file.\");\n                    u.set_state(\"finished\");\n                    u.settings.on_progress.call(u, u.file.size, u.file.size); // it's 100% done\n\n                    u.notify_upload_finished();\n\n                    // trigger the complete event callback\n                    u.settings.on_complete.call(u);\n                } else if(e.target.status == 400 &&\n                        e.target.responseText.indexOf(\"EntityTooSmall\") !== -1) {\n                    // an \"EntityTooSmall\" error means that we missed a chunk\n                    u.list_parts(function(parts) {\n                        u.update_chunks(parts);\n                        var next_chunk = u.get_next_chunk();\n                        u.set_state(\"processing\");\n                        u.upload_chunk(next_chunk);\n                    });\n                } else if(e.target.status == 404) {\n                    // 404 = NoSuchUpload = check if already finished\n                    // if so, start a new upload\n                    u.cancel(function() {\n                        u.upload_file(u.file, true);\n                    });\n                } else {\n                    u.check_already_uploaded(function() {\n                        handler({\n                            target: {\n                                status: 200\n                            }\n                        });\n                    }, function() {\n                        handler({\n                            target: {\n                                status: 404\n                            }\n                        });\n                    });\n                }\n            };\n\n            // get the uploaded parts from S3\n            u.list_parts(function(parts) {\n                var num_chunks = Math.ceil(u.file.size / u.settings.chunk_size);\n\n                // check that we uploaded all the chunks; if we didn't,\n                // start uploading the missing ones\n                if(parts.length != num_chunks) {\n                    u.update_chunks(parts);\n                    var next_chunk = u.get_next_chunk();\n                    u.set_state(\"processing\");\n                    u.upload_chunk(next_chunk);\n                    return;\n                }\n\n                // compose the CompleteMultipartUpload request for putting\n                // the chunks together\n                var data = \"<CompleteMultipartUpload>\";\n                for(var i=0; i<parts.length; i++) {\n                    data += \"<Part>\";\n                    data += \"<PartNumber>\" + parts[i][0] + \"</PartNumber>\";\n                    data += \"<ETag>\" + parts[i][1] + \"</ETag>\";\n                    data += \"</Part>\";\n                }\n                data += \"</CompleteMultipartUpload>\";\n\n                // firefox requires a small hack\n                if(navigator.userAgent.indexOf(\"Firefox\") !== -1) {\n                    data = new Blob([data]);\n                }\n\n                // send the ajax request\n                //\n                XHR({\n                    url: u.settings.host + path,\n                    method: \"POST\",\n                    load_callback: handler,\n                    error_callback: handler,\n                    headers: {\n                        \"x-amz-date\": date,\n                        \"Authorization\": authorization,\n                        \"Content-Type\": u.settings.content_type,\n                        \"Content-Disposition\": \"attachment; filename=\" + u.file.name\n                    },\n                    body: data\n                });\n            });\n        });\n    };\n\n    // gets the uploaded chunks from S3. This is useful when comparing\n    // the parts known by the uploader to the parts reported by S3, and also\n    // for getting the chunk ETag's, which are needed when finishing uploads\n    Uploader.prototype.list_parts = function(callback, error_callback, part_marker) {\n        var u = this;\n        u.get_list_signature(function(signature, date) {\n            var handler = function(e) {\n                // if it's not a 2XX response, trigger the error callback\n                if(e.target.status / 100 != 2 && error_callback) {\n                    return error_callback(e);\n                }\n\n                // process the parts, and return an array of\n                // [part_number, etag, size] through the given callback\n                var xml = e.target.responseXML;\n                var parts = [];\n                var xml_parts = xml.getElementsByTagName(\"Part\");\n                var num_chunks = Math.ceil(u.file.size / u.settings.chunk_size);\n                for(var i=0; i < xml_parts.length; i++) {\n                    var part_number = parseInt(xml_parts[i].getElementsByTagName(\"PartNumber\")[0].textContent, 10);\n                    var etag = xml_parts[i].getElementsByTagName(\"ETag\")[0].textContent;\n                    var size = parseInt(xml_parts[i].getElementsByTagName(\"Size\")[0].textContent, 10);\n\n                    if(part_number != num_chunks && size != u.settings.chunk_size) {\n                        continue; // chunk corrupted\n                    } else if(part_number == num_chunks &&\n                            size != u.file.size % u.settings.chunk_size) {\n                        continue; // final chunk corrupted\n                    }\n\n                    parts.push([\n                        part_number,\n                        etag,\n                        size\n                    ]);\n                }\n                var is_truncated = xml.getElementsByTagName(\"IsTruncated\")[0].textContent;\n                if(is_truncated === \"true\") {\n                    var part_marker = xml.getElementsByTagName(\"NextPartNumberMarker\")[0].textContent;\n                    u.list_parts(function(new_parts) {\n                        callback(parts.concat(new_parts));\n                    }, error_callback, part_marker);\n                } else {\n                    callback(parts);\n                }\n            };\n            var path = \"/\" + u.settings.key + \"?uploadId=\" + u.upload_id;\n            if(part_marker) {\n                path = path + \"&part-number-marker=\" + part_marker;\n            }\n            var method = \"GET\";\n            var authorization = \"AWS \" + u.settings.access_key + \":\" + signature;\n            XHR({\n                method: \"GET\",\n                load_callback: handler,\n                url: u.settings.host + path,\n                headers: {\n                    \"x-amz-date\": date,\n                    \"Authorization\": authorization\n                }\n            });\n        });\n    };\n\n    // gets the end signature, needed for finishing an upload\n    Uploader.prototype.get_end_signature = function(callback) {\n        var u = this;\n\n        // if we already have the signature, return that\n        // if(u._end_signature) {\n        //     callback(u._end_signature[0], u._end_signature[1]);\n        //     return;\n        // }\n        var handler = function(e) {\n            var response = JSON.parse(e.target.responseText);\n            callback(response.signature, response.date);\n        };\n        var error_handler = function() {\n            // if there's an error, retry after one second\n            setTimeout(function() {\n                u.get_end_signature(callback);\n            }, 1000);\n        };\n        var url = u.settings.ajax_base + \"/get_end_signature/?upload_id=\" + escape(this.upload_id)\n                + \"&mime_type=\" + encodeURIComponent(u.settings.content_type)\n                + \"&key=\" + this.settings.key + \"&collectionId=\" + u.settings.collectionId;\n\n        XHR({\n            url: url,\n            extra_params: u.settings.extra_params,\n            load_callback: handler,\n            error_callback: error_handler\n        });\n    };\n\n    // gets the list signature, needed for listing the upload's chunks\n    // see `Uploader.prototype.list_parts`\n    Uploader.prototype.get_list_signature = function(callback, error_callback) {\n        var u = this;\n        error_callback = error_callback || function() {};\n\n        // if we already have the signature, return that\n        // if(u._list_signature) {\n        //     callback(u._list_signature[0], u._list_signature[1]);\n        //     return;\n        // }\n        var handler = function(e) {\n            var response = JSON.parse(e.target.responseText);\n            callback(response.signature, response.date);\n        };\n        var error_handler = function(e) {\n            // if there's an error, retry after one second\n            // (think server hiccups, internet connection temporarily\n            // disabled, etc.)\n            setTimeout(function() {\n                u.get_list_signature(callback);\n            }, 1000);\n        };\n        var url = u.settings.ajax_base + \"/get_list_signature/?upload_id=\" + escape(this.upload_id)\n                + \"&mime_type=\" + encodeURIComponent(u.settings.content_type)\n                + \"&key=\" + this.settings.key + \"&collectionId=\" + u.settings.collectionId;\n        XHR({\n            url: url,\n            extra_params: u.settings.extra_params,\n            load_callback: handler,\n            error_callback: error_handler\n        });\n    };\n\n    // gets the signature for one chunk upload\n    Uploader.prototype.get_chunk_signature = function(chunk, callback) {\n        var u = this;\n\n        // if we already have the signature, return that.\n        // note the 0-indexing vs 1-indexing between what we have locally and\n        // what S3 gives us\n        // if(u._chunk_signatures && u._chunk_signatures[chunk + 1]) {\n        //     callback(u._chunk_signatures[chunk + 1][0], u._chunk_signatures[chunk + 1][1]);\n        //     return;\n        // }\n        var handler = function(e) {\n            var response = JSON.parse(e.target.responseText);\n            callback(response.signature, response.date);\n        };\n        var error_handler = function(e) {\n            // if there's an error, retry after one second\n            setTimeout(function() {\n                u.get_chunk_signature(chunk, callback);\n            }, 1000);\n        };\n        var url = u.settings.ajax_base + \"/get_chunk_signature/?chunk=\"\n            + (chunk + 1) + \"&upload_id=\" + escape(this.upload_id)\n            + \"&mime_type=\" + encodeURIComponent(u.settings.content_type)\n            + \"&collectionId=\" + u.settings.collectionId\n            + \"&key=\" + this.settings.key;\n        XHR({\n            url: url,\n            extra_params: u.settings.extra_params,\n            load_callback: handler,\n            error_callback: error_handler\n        });\n    };\n\n    // gets the init signature, needed for starting an upload\n    Uploader.prototype.get_init_signature = function(callback, force) {\n        var u = this;\n        var num_chunks = Math.ceil(u.file.size / u.settings.chunk_size);\n        var handler = function(e) {\n            var response = JSON.parse(e.target.responseText);\n\n            // the server may also respond with chunks already loaded\n            if(response.chunks) {\n                if(response.chunks.length == num_chunks) {\n                    return u.get_init_signature(callback, true);\n                }\n                log(\"Resume upload...\");\n                var chunks = response.chunks;\n                u._progress = u._progress || [];\n                for(var i=0; i < chunks.length; i++) {\n                    log(\"Chunk already uploaded: \" + (chunks[i] - 1));\n                    var chunk_size = u.get_chunk_size(chunks[i]);\n                    u._progress[chunks[i]] = chunk_size;\n                    u._total_progress += chunk_size;\n\n                    u.add_loaded_chunk(chunks[i] - 1);\n                    u.set_chunk_finished(chunks[i] - 1);\n                    u.bytes_started = (u.bytes_started || 0) + u.settings.chunk_size;\n                }\n                u.upload_id = response.upload_id;\n                u.settings.key = response.key;\n            }\n            callback(response.signature, response.date);\n        };\n        var error_handler = function() {\n            log(\"Failed; trying again\");\n            // if it fails, retry after waiting one second\n            setTimeout(function() {\n                u.get_init_signature(callback);\n            }, 1000);\n        };\n        var url = u.settings.ajax_base + \"/get_init_signature/?key=\" + u.settings.key\n                + \"&mime_type=\" + encodeURIComponent(u.settings.content_type)\n                + \"&filename=\" + escape(u.file.name)\n                + \"&filesize=\" + u.file.size\n                + \"&upload_id=\" + u.upload_id\n                + \"&collectionId=\" + u.settings.collectionId\n                + \"&last_modified=\" + u.file.lastModifiedDate.valueOf() + \"&collectionId=\" + u.settings.collectionId\n                + (force ? \"&force=true\" : \"\");\n        XHR({\n            url: url,\n            extra_params: u.settings.extra_params,\n            load_callback: handler,\n            error_callback: error_handler\n        });\n    };\n\n    // gets all the signatures: init, list, chunks and finish\n    // much more convenient than getting them one at a time\n    Uploader.prototype.get_all_signatures = function(callback) {\n        var u = this;\n        var key = u.settings.key;\n        var num_chunks = Math.ceil(u.file.size / u.settings.chunk_size);\n        var upload_id = u.upload_id;\n        var handler = function(e) {\n            var response = JSON.parse(e.target.responseText);\n            u._chunk_signatures = response.chunk_signatures;\n            u._list_signature = response.list_signature;\n            u._end_signature = response.end_signature;\n            u._delete_signature = response.delete_signature;\n            callback();\n        };\n        var error_handler = function() {\n            // if it fails, wait one second and try again\n            setTimeout(function() {\n                u.get_all_signatures(callback);\n            }, 1000);\n        };\n        var url = u.settings.ajax_base + \"/get_all_signatures/?key=\" + key\n                + \"&mime_type=\" + encodeURIComponent(u.settings.content_type)\n                + \"&num_chunks=\" + num_chunks\n                + \"&upload_id=\" + upload_id\n                + \"&filename=\" + escape(u.file.name)\n                + \"&filesize=\" + u.file.size\n                + \"&collectionId=\" + u.settings.collectionId\n                + \"&last_modified=\" + u.file.lastModifiedDate.valueOf();\n        XHR({\n            url: url,\n            extra_params: u.settings.extra_params,\n            load_callback: handler,\n            error_callback: error_handler\n        });\n    };\n\n    // notify the server that a chunk finished uploading. This is needed for\n    // upload resumes\n    Uploader.prototype.notify_chunk_uploaded = function(chunk) {\n        var u = this;\n        if(u.get_state() != \"processing\") {\n            return;\n        }\n        var key = u.settings.key;\n        var upload_id = u.upload_id;\n        var url = u.settings.ajax_base + '/chunk_loaded/?key=' + key + \"&chunk=\" + (chunk + 1)\n            + \"&mime_type=\" + encodeURIComponent(u.settings.content_type)\n            + \"&upload_id=\" + upload_id + \"&filename=\" + escape(u.file.name)\n            + \"&collectionId=\" + u.settings.collectionId\n            + \"&filesize=\" + u.file.size + \"&last_modified=\" + u.file.lastModifiedDate.valueOf();\n        XHR({\n            url: url,\n            extra_params: u.settings.extra_params\n        });\n    };\n\n    Uploader.prototype.notify_upload_finished = function(callback) {\n        var u = this;\n        if(u.get_state() != \"finished\") {\n            return;\n        }\n        var key = u.settings.key;\n        var upload_id = u.upload_id;\n        var url = u.settings.ajax_base + '/upload_finished/?key=' + key\n            + \"&mime_type=\" + encodeURIComponent(u.settings.content_type)\n            + \"&upload_id=\" + upload_id + \"&filename=\" + escape(u.file.name)\n            + \"&collectionId=\" + u.settings.collectionId\n            + \"&filesize=\" + u.file.size + \"&last_modified=\" + u.file.lastModifiedDate.valueOf();\n        XHR({\n            url: url,\n            extra_params: u.settings.extra_params\n        });\n    };\n\n    // check whether the file is already uploaded\n    Uploader.prototype.check_already_uploaded = function(callback, error_callback) {\n        var u = this;\n        var method = \"HEAD\";\n        var path = \"/\" + u.settings.key;\n        var inner_handler = function(e) {\n            // the handler only checks for status code;\n            // if the HEAD returns 404, re-upload,\n            // else, it returns 200 and finish the upload\n            if(e.target.status / 100 == 2) {\n                log(\"Already Uploaded\");\n                callback();\n            } else {\n                log(\"Error!\");\n                error_callback();\n            }\n        };\n\n        if(!error_callback && typeof(error_callback) !== \"function\") {\n            error_callback = function() {\n                setTimeout(function() {\n                    return u.check_already_uploaded(callback, error_callback);\n                }, 2500);\n            };\n        }\n\n        XHR({\n            url: u.settings.host + path,\n            method: \"HEAD\",\n            load_callback: inner_handler,\n            error_callback: error_callback,\n        });\n    };\n\n    // cancels an upload\n    Uploader.prototype.cancel = function(callback) {\n        // empty all fields, cancel all intervals, abort all xhr's\n        var u = this;\n        for(var i=0; i < u._chunk_xhr.length; i++) {\n            log(\"Abort chunk: \" + u._chunk_xhr[i]);\n            u._chunk_xhr[i].abort();\n        }\n        u._intervals = u._intervals || {};\n        for(var x in u._intervals) {\n            clearInterval(u._intervals[x]);\n        }\n        callback = callback || function() {};\n        u.set_state(\"canceled\");\n        u._chunk_xhr = u._chunk_xhr || [];\n        u.settings.on_progress.call(u, 0, 0);\n        u._chunk_xhr = null;\n        u._chunks = null;\n        u._uploading_chunks = null;\n        u._loaded_chunks = null;\n        u._start_fired = false;\n        u.upload_id = null;\n        u._progress = null;\n        u._chunk_signatures = null;\n        u._list_signature = null;\n        u._end_signature = null;\n        u._delete_signature = null;\n        u.set_state(\"waiting\"); // wait for a new upload\n        callback();\n    };\n\n    // updates the chunk history with the given chunks\n    Uploader.prototype.update_chunks = function(parts) {\n        var u = this;\n        var loaded = [];\n        var num_chunks = Math.ceil(u.file.size / u.settings.chunk_size);\n\n        u._init_chunks(true);\n        u._uploading_chunks = [];\n        u._loaded_chunks = [];\n\n        for(var i=0; i < parts.length; i++) {\n            var part_number = parseInt(parts[i][0], 10);\n            u.add_loaded_chunk(part_number - 1);\n            u.set_chunk_finished(part_number - 1);\n            loaded.push(part_number - 1);\n        }\n        for(var i=0; i < num_chunks; i++) {\n            if(loaded.indexOf(i) === -1) {\n                log(\"Chunk not uploaded: \", i);\n                u.set_progress(i, 0);\n            }\n        }\n    };\n\n    // returns true if a file is selected\n    Uploader.prototype.is_selected = function() {\n        return !!this.file;\n    };\n\n    // returns the uploader's state\n    Uploader.prototype.get_state = function() {\n        return this._state;\n    };\n\n    // sets the uploader's state\n    Uploader.prototype.set_state = function(state) {\n        return this._state = state;\n    };\n\n    // set a chunk's progress\n    Uploader.prototype.set_progress = function(chunk, loaded) {\n        var num_chunks = Math.ceil(this.file.size / this.settings.chunk_size);\n        this.log_status();\n        this._progress = this._progress || {};\n        this._total_progress = (this._total_progress || 0 ) + loaded - (this._progress[chunk] || 0);\n        this._progress[chunk] = loaded;\n        this.settings.on_chunk_progress.call(\n            this, chunk, loaded, this.get_chunk_size(chunk));\n    };\n\n    // gets the total bytes uploaded\n    Uploader.prototype.get_total_progress = function() {\n        return this._total_progress || 0;\n    };\n\n    // returns true if a chunk is already uploaded\n    Uploader.prototype.is_chunk_loaded = function(chunk) {\n        this._loaded_chunks = this._loaded_chunks || [];\n        return this._loaded_chunks.indexOf(chunk) !== -1;\n    };\n\n    // adds a chunk to the uploaded list\n    Uploader.prototype.add_loaded_chunk = function(chunk) {\n        this._loaded_chunks = this._loaded_chunks || [];\n        this._loaded_chunks.push(chunk);\n        this.set_progress(chunk, this.get_chunk_size(chunk));\n    };\n\n    // returns true if the chunk is currently uploading\n    Uploader.prototype.get_chunk_uploading = function(chunk) {\n        this._uploading_chunks = this._uploading_chunks || [];\n        return this._uploading_chunks.indexOf(chunk) !== -1;\n    };\n\n    // sets whether a chunk is currently uploading or not\n    Uploader.prototype.set_chunk_uploading = function(chunk, val) {\n        if(typeof val == \"undefined\") {\n            val = true;\n        }\n        this._uploading_chunks = this._uploading_chunks || [];\n        if(val) {\n            this._uploading_chunks.push(chunk);\n        } else {\n            var list = [];\n            for(var i=0; i < this._uploading_chunks.length; i++) {\n                if(this._uploading_chunks[i] != chunk) {\n                    list.push(this._uploading_chunks[i]);\n                }\n            }\n            this._uploading_chunks = list;\n        }\n    };\n\n    // initialize inner representation of chunks\n    Uploader.prototype._init_chunks = function(force) {\n        var u = this;\n        if(!u._chunks || force) {\n            u._chunks = [];\n            var num_chunks = Math.ceil(u.file.size / u.settings.chunk_size);\n            for(var i=0; i < num_chunks; i++) {\n                u._chunks.push(false);\n            }\n        }\n    };\n\n    // sets whether a chunk finished uploading\n    Uploader.prototype.set_chunk_finished = function(chunk, val) {\n        if(typeof val == \"undefined\") {\n            val = true;\n        }\n        var u = this;\n        u._init_chunks();\n        u._chunks[chunk] = val;\n    };\n\n    // get next chunk to be uploaded; if all chunks are done, return -1\n    Uploader.prototype.get_next_chunk = function(chunk) {\n        var u = this;\n        u._init_chunks();\n        if(chunk && !u._chunks[chunk] && !u.get_chunk_uploading(chunk)) {\n            return chunk;\n        }\n        for(var i=0; i < u._chunks.length; i++) {\n            if(!u._chunks[i] && !u.get_chunk_uploading(i)) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    // returns true if all chunks finished uploaded\n    Uploader.prototype.upload_finished = function() {\n        var u = this;\n        u._init_chunks();\n        for(var i=0; i < u._chunks.length; i++) {\n            if(!u._chunks[i] || u.get_chunk_uploading(i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Uploader.prototype.is_last_chunk = function(chunk) {\n        return Math.ceil(this.file.size / this.settings.chunk_size) == chunk - 1;\n    }\n\n    Uploader.prototype.get_chunk_size = function(chunk) {\n        if(this.is_last_chunk(chunk)) {\n            return this.file.size % this.settings.chunk_size;\n        } else {\n            return this.settings.chunk_size;\n        }\n    }\n\n    Uploader.prototype.log_status = function() {\n        // log(this.get_total_progress() / this.file.size * 100);\n    }\n\n    Uploader.prototype.on_chunk_progress = function(f) { u.settings.on_chunk_progress = f; };\n    Uploader.prototype.on_progress = function(f) { u.settings.on_progress = f; };\n    Uploader.prototype.on_select = function(f) { u.settings.on_select = f; };\n    Uploader.prototype.on_error = function(f) { u.settings.on_error = f; };\n    Uploader.prototype.on_complete = function(f) { u.settings.on_complete = f; };\n    Uploader.prototype.on_init = function(f) { u.settings.on_init = f; };\n    Uploader.prototype.on_start = function(f) { u.settings.on_start = f; };\n    Uploader.prototype.on_chunk_uploaded = function(f) { u.settings.on_chunk_uploaded = f; };\n\n    return new Uploader(settings);\n};\n"],"sourceRoot":"/source/"}