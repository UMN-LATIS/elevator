{"version":3,"sources":["markerclusterer.js"],"names":["MarkerClusterer","map","opt_markers","opt_options","this","extend","google","maps","OverlayView","map_","markers_","clusters_","sizes","styles_","ready_","options","gridSize_","minClusterSize_","maxZoom_","imagePath_","MARKER_CLUSTER_IMAGE_PATH_","imageExtension_","MARKER_CLUSTER_IMAGE_EXTENSION_","zoomOnClick_","undefined","averageCenter_","setupStyles_","setMap","prevZoom_","getZoom","that","event","addListener","zoom","resetViewport","redraw","length","addMarkers","Cluster","markerClusterer","markerClusterer_","getMap","getGridSize","getMinClusterSize","isAverageCenter","center_","bounds_","clusterIcon_","ClusterIcon","getStyles","cluster","styles","opt_padding","getMarkerClusterer","padding_","cluster_","div_","sums_","visible_","prototype","obj1","obj2","object","property","apply","onAdd","setReady_","draw","size","i","push","url","height","width","fitMapToMarkers","marker","markers","getMarkers","bounds","LatLngBounds","getPosition","fitBounds","setStyles","isZoomOnClick","getTotalMarkers","setMaxZoom","maxZoom","getMaxZoom","calculator_","numStyles","index","count","dv","parseInt","Math","min","text","setCalculator","calculator","getCalculator","opt_nodraw","pushMarkerTo_","isAdded","repaint","addMarker","removeMarker_","indexOf","m","splice","removeMarker","removed","removeMarkers","r","ready","createClusters_","getTotalClusters","setGridSize","setMinClusterSize","getExtendedBounds","projection","getProjection","tr","LatLng","getNorthEast","lat","lng","bl","getSouthWest","trPix","fromLatLngToDivPixel","x","y","blPix","ne","fromDivPixelToLatLng","sw","isMarkerInBounds_","contains","clearMarkers","opt_hide","remove","oldClusters","slice","window","setTimeout","distanceBetweenPoints_","p1","p2","R","dLat","PI","dLon","a","sin","cos","c","atan2","sqrt","d","addToClosestCluster_","distance","clusterToAddTo","center","getCenter","isMarkerInClusterBounds","mapBounds","getBounds","isMarkerAlreadyAdded","l","calculateBounds_","len","updateIcon","getSize","mz","hide","sums","setCenter","setSums","show","triggerClusterClick","trigger","document","createElement","pos","getPosFromLatLng_","style","cssText","createCss","innerHTML","panes","getPanes","overlayMouseTarget","appendChild","addDomListener","latlng","iconAnchor_","width_","height_","top","left","display","onRemove","parentNode","removeChild","text_","index_","useStyle","max","url_","textColor_","anchor_","textSize_","backgroundPosition_","backgroundPosition","txtColor","txtSize","join"],"mappings":"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","file":"markerclusterer.min.js","sourcesContent":["// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js\n// ==/ClosureCompiler==\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n * <br/>\n * This is a v3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >v2 MarkerClusterer</a>.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'averageCenter': (boolean) Wether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n *       'iconAnchor': (Array) The anchor position of the icon x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  this.map_ = map;\n\n  /**\n   * @type {Array.<google.maps.Marker>}\n   * @private\n   */\n  this.markers_ = [];\n\n  /**\n   *  @type {Array.<Cluster>}\n   */\n  this.clusters_ = [];\n\n  this.sizes = [53, 56, 66, 78, 90];\n\n  /**\n   * @private\n   */\n  this.styles_ = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.ready_ = false;\n\n  var options = opt_options || {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.gridSize_ = options['gridSize'] || 60;\n\n  /**\n   * @private\n   */\n  this.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.maxZoom_ = options['maxZoom'] || null;\n\n  this.styles_ = options['styles'] || [];\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imagePath_ = options['imagePath'] ||\n      this.MARKER_CLUSTER_IMAGE_PATH_;\n\n  /**\n   * @type {string}\n   * @private\n   */\n  this.imageExtension_ = options['imageExtension'] ||\n      this.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.zoomOnClick_ = true;\n\n  if (options['zoomOnClick'] != undefined) {\n    this.zoomOnClick_ = options['zoomOnClick'];\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.averageCenter_ = false;\n\n  if (options['averageCenter'] != undefined) {\n    this.averageCenter_ = options['averageCenter'];\n  }\n\n  this.setupStyles_();\n\n  this.setMap(map);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevZoom_ = this.map_.getZoom();\n\n  // Add the map event listeners\n  var that = this;\n  google.maps.event.addListener(this.map_, 'zoom_changed', function() {\n    var zoom = that.map_.getZoom();\n\n    if (that.prevZoom_ != zoom) {\n      that.prevZoom_ = zoom;\n      that.resetViewport();\n    }\n  });\n\n  google.maps.event.addListener(this.map_, 'idle', function() {\n    that.redraw();\n  });\n\n  // Finally, add the markers\n  if (opt_markers && opt_markers.length) {\n    this.addMarkers(opt_markers, false);\n  }\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =\n    'https://raw.githubusercontent.com/googlemaps/js-marker-clusterer/gh-pages/images/m' +\n    'images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n  return (function(object) {\n    for (var property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n  this.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n  if (this.styles_.length) {\n    return;\n  }\n\n  for (var i = 0, size; size = this.sizes[i]; i++) {\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n\n  this.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n  return this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n  return this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n  return this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n  return this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n  var index = 0;\n  var count = markers.length;\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index\n  };\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n  return this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    this.pushMarkerTo_(marker);\n  }\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n  marker.isAdded = false;\n  if (marker['draggable']) {\n    // If the marker is draggable add a listener so we update the clusters on\n    // the drag end.\n    var that = this;\n    google.maps.event.addListener(marker, 'dragend', function() {\n      marker.isAdded = false;\n      that.repaint();\n    });\n  }\n  this.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw();\n  }\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index == -1) {\n    // Marker is not in our list of markers.\n    return false;\n  }\n\n  marker.setMap(null);\n\n  this.markers_.splice(index, 1);\n\n  return true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  } else {\n   return false;\n  }\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n  var removed = false;\n\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    var r = this.removeMarker_(marker);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.resetViewport();\n    this.redraw();\n    return true;\n  }\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n  if (!this.ready_) {\n    this.ready_ = ready;\n    this.createClusters_();\n  }\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n  return this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n  this.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n  this.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n  this.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n  this.resetViewport(true);\n\n  // Set the markers a empty array.\n  this.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n  // Remove all the clusters\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    cluster.remove();\n  }\n\n  // Reset the markers to not be added and to be invisible.\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n\n  this.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_.length = 0;\n  this.resetViewport();\n  this.redraw();\n\n  // Remove the old clusters.\n  // Do it in a timeout so the other clusters have been drawn first.\n  window.setTimeout(function() {\n    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n      cluster.remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n  this.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n  if (!p1 || !p2) {\n    return 0;\n  }\n\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  var pos = marker.getPosition();\n  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n    var center = cluster.getCenter();\n    if (center) {\n      var d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    var cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n  if (!this.ready_) {\n    return;\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n      this.map_.getBounds().getNorthEast());\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  for (var i = 0, marker; marker = this.markers_[i]; i++) {\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      this.addToClosestCluster_(marker);\n    }\n  }\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n  this.markerClusterer_ = markerClusterer;\n  this.map_ = markerClusterer.getMap();\n  this.gridSize_ = markerClusterer.getGridSize();\n  this.minClusterSize_ = markerClusterer.getMinClusterSize();\n  this.averageCenter_ = markerClusterer.isAverageCenter();\n  this.center_ = null;\n  this.markers_ = [];\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n      markerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) != -1;\n  } else {\n    for (var i = 0, m; m = this.markers_[i]; i++) {\n      if (m == marker) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n  if (this.isMarkerAlreadyAdded(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  var len = this.markers_.length;\n  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n    // Min cluster size not reached so show the marker.\n    marker.setMap(this.map_);\n  }\n\n  if (len == this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (var i = 0; i < len; i++) {\n      this.markers_[i].setMap(null);\n    }\n  }\n\n  if (len >= this.minClusterSize_) {\n    marker.setMap(null);\n  }\n\n  this.updateIcon();\n  return true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (var i = 0, marker; marker = markers[i]; i++) {\n    bounds.extend(marker.getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n  this.clusterIcon_.remove();\n  this.markers_.length = 0;\n  delete this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {number} The cluster center.\n */\nCluster.prototype.getSize = function() {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {Array.<google.maps.Marker>} The cluster center.\n */\nCluster.prototype.getMarkers = function() {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n  return this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n  return this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n  var zoom = this.map_.getZoom();\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz && zoom > mz) {\n    // The zoom is greater than our max zoom so show all the markers in cluster.\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\n      marker.setMap(this.map_);\n    }\n    return;\n  }\n\n  if (this.markers_.length < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.setSums(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.styles_ = styles;\n  this.padding_ = opt_padding || 0;\n  this.cluster_ = cluster;\n  this.center_ = null;\n  this.map_ = cluster.getMap();\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n *\n * @param {google.maps.MouseEvent} event The event to propagate\n */\nClusterIcon.prototype.triggerClusterClick = function(event) {\n  var markerClusterer = this.cluster_.getMarkerClusterer();\n\n  // Trigger the clusterclick event.\n  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_, event);\n\n  if (markerClusterer.isZoomOnClick()) {\n    // Zoom into the cluster.\n    this.map_.fitBounds(this.cluster_.getBounds());\n  }\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n  this.div_ = document.createElement('DIV');\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.innerHTML = this.sums_.text;\n  }\n\n  var panes = this.getPanes();\n  panes.overlayMouseTarget.appendChild(this.div_);\n\n  var that = this;\n  google.maps.event.addDomListener(this.div_, 'click', function(event) {\n    that.triggerClusterClick(event);\n  });\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n\n  if (typeof this.iconAnchor_ === 'object' && this.iconAnchor_.length === 2) {\n    pos.x -= this.iconAnchor_[0];\n    pos.y -= this.iconAnchor_[1];\n  } else {\n    pos.x -= parseInt(this.width_ / 2, 10);\n    pos.y -= parseInt(this.height_ / 2, 10);\n  }\n  return pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + 'px';\n    this.div_.style.left = pos.x + 'px';\n  }\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n  if (this.div_) {\n    this.div_.style.display = 'none';\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n  if (this.div_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    this.div_.style.display = '';\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n  this.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n  this.sums_ = sums;\n  this.text_ = sums.text;\n  this.index_ = sums.index;\n  if (this.div_) {\n    this.div_.innerHTML = sums.text;\n  }\n\n  this.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n  var index = Math.max(0, this.sums_.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style['url'];\n  this.height_ = style['height'];\n  this.width_ = style['width'];\n  this.textColor_ = style['textColor'];\n  this.anchor_ = style['anchor'];\n  this.textSize_ = style['textSize'];\n  this.backgroundPosition_ = style['backgroundPosition'];\n  this.iconAnchor_ = style['iconAnchor'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n  this.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n  var style = [];\n  style.push('background-image:url(' + this.url_ + ');');\n  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n  style.push('background-position:' + backgroundPosition + ';');\n\n  if (typeof this.anchor_ === 'object') {\n    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n        this.anchor_[0] < this.height_) {\n      style.push('height:' + (this.height_ - this.anchor_[0]) +\n          'px; padding-top:' + this.anchor_[0] + 'px;');\n    } else if (typeof this.anchor_[0] === 'number' && this.anchor_[0] < 0 &&\n        -this.anchor_[0] < this.height_) {\n      style.push('height:' + this.height_ + 'px; line-height:' + (this.height_ + this.anchor_[0]) +\n          'px;');\n    } else {\n      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n          'px;');\n    }\n    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n        this.anchor_[1] < this.width_) {\n      style.push('width:' + (this.width_ - this.anchor_[1]) +\n          'px; padding-left:' + this.anchor_[1] + 'px;');\n    } else {\n      style.push('width:' + this.width_ + 'px; text-align:center;');\n    }\n  } else {\n    style.push('height:' + this.height_ + 'px; line-height:' +\n        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n  }\n\n  var txtColor = this.textColor_ ? this.textColor_ : 'black';\n  var txtSize = this.textSize_ ? this.textSize_ : 11;\n\n  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n  return style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nwindow['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n    MarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n    MarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n    MarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n    MarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n    MarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n    MarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n    MarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n    MarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n    MarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n    MarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n    MarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n    MarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n    MarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n    MarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;\n"],"sourceRoot":"/source/"}