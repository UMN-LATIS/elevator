{"version":3,"sources":["crocodoc.viewer.js"],"names":["window","Crocodoc","fn","exports","jQuery","module","$","PROXY_SVG","loadSVG","svgText","domParser","DOMParser","svgDoc","parseFromString","svgEl","document","importNode","documentElement","setAttribute","body","appendChild","CSS_CLASS_PREFIX","ATTR_SVG_VERSION","CSS_CLASS_VIEWER","CSS_CLASS_DOC","CSS_CLASS_VIEWPORT","CSS_CLASS_LOGO","CSS_CLASS_DRAGGABLE","CSS_CLASS_DRAGGING","CSS_CLASS_TEXT_SELECTED","CSS_CLASS_TEXT_DISABLED","CSS_CLASS_LINKS_DISABLED","CSS_CLASS_MOBILE","CSS_CLASS_IELT9","CSS_CLASS_SUPPORTS_SVG","CSS_CLASS_WINDOW_AS_VIEWPORT","CSS_CLASS_LAYOUT_PREFIX","CSS_CLASS_CURRENT_PAGE","CSS_CLASS_PRECEDING_PAGE","CSS_CLASS_PAGE","CSS_CLASS_PAGE_INNER","CSS_CLASS_PAGE_CONTENT","CSS_CLASS_PAGE_SVG","CSS_CLASS_PAGE_TEXT","CSS_CLASS_PAGE_LINK","CSS_CLASS_PAGE_LINKS","CSS_CLASS_PAGE_AUTOSCALE","CSS_CLASS_PAGE_LOADING","CSS_CLASS_PAGE_ERROR","CSS_CLASS_PAGE_VISIBLE","CSS_CLASS_PAGE_PREV","CSS_CLASS_PAGE_NEXT","CSS_CLASS_PAGE_BEFORE","CSS_CLASS_PAGE_AFTER","CSS_CLASS_PAGE_BEFORE_BUFFER","CSS_CLASS_PAGE_AFTER_BUFFER","PRESENTATION_CSS_CLASSES","join","VIEWER_HTML_TEMPLATE","PAGE_HTML_TEMPLATE","DOCUMENT_100_PERCENT_WIDTH","ZOOM_FIT_WIDTH","ZOOM_FIT_HEIGHT","ZOOM_AUTO","ZOOM_IN","ZOOM_OUT","SCROLL_PREVIOUS","SCROLL_NEXT","LAYOUT_VERTICAL","LAYOUT_VERTICAL_SINGLE_COLUMN","LAYOUT_HORIZONTAL","LAYOUT_PRESENTATION","LAYOUT_PRESENTATION_TWO_PAGE","LAYOUT_TEXT","PAGE_STATUS_CONVERTING","PAGE_STATUS_NOT_LOADED","PAGE_STATUS_LOADING","PAGE_STATUS_LOADED","PAGE_STATUS_ERROR","STYLE_PADDING_PREFIX","STYLE_PADDING_TOP","STYLE_PADDING_RIGHT","STYLE_PADDING_LEFT","STYLE_PADDING_BOTTOM","ZOOM_LEVEL_SIMILARITY_THRESHOLD","ZOOM_LEVEL_PRESETS_SIMILARITY_THRESHOLD","PAGE_LOAD_INTERVAL","MAX_PAGE_LOAD_RANGE","MAX_PAGE_LOAD_RANGE_MOBILE","READY_TRIGGER_PRELOADING_DELAY","SVG_MIME_TYPE","HTML_TEMPLATE","SVG_CONTAINER_TEMPLATE","EMBED_STRATEGY_IFRAME_INNERHTML","EMBED_STRATEGY_DATA_URL","EMBED_STRATEGY_INLINE_SVG","EMBED_STRATEGY_BASIC_OBJECT","EMBED_STRATEGY_BASIC_IMG","EMBED_STRATEGY_DATA_URL_PROXY","EMBED_STRATEGY_IFRAME_PROXY","EMBED_STRATEGY_DATA_URL_IMG","Error","findCircularDependencies","componentName","dependencies","path","i","length","components","mixins","utilities","ASSET_REQUEST_RETRIES","viewerTemplate","pageTemplate","createViewer","el","config","Viewer","getViewer","id","get","addComponent","name","creator","Function","createComponent","scope","component","args","push","this","unshift","apply","addPlugin","addDataProvider","modelName","addUtility","instance","getUtility","utility","Scope","broadcast","messageName","data","len","messages","instances","util","inArray","isFn","onmessage","call","broadcastQueuedMessages","message","messageQueue","shift","destroyComponent","destroy","_destroyed","dataProviders","ready","splice","slice","getConfig","objectType","objectKey","newObjectType","provider","getDataProvider","Deferred","reject","promise","buildEventObject","type","isDefaultPrevented","preventDefault","EventTarget","_handlers","prototype","constructor","on","handler","fire","handlers","event","Array","concat","all","off","one","self","proxy","viewerInstanceCount","options","init","viewerBase","layout","$el","extend","defaults","api","load","loadAssets","setLayout","mode","zoom","val","valFloat","parseFloat","pageScale","setZoom","scrollTo","page","scrollBy","left","top","focus","enableTextSelection","toggleClass","enabled","disableTextSelection","enableLinks","removeClass","disableLinks","addClass","updateLayout","update","url","enableDragging","queryParams","plugins","useWindowAsViewport","conversionIsComplete","template","svg","img","html","css","json","metadata","stylesheet","page-svg","page-text","page-img","pageStart","pageEnd","autoloadFirstPage","zoomLevels","processJSONContent","parseJSON","ajax","getURL","$promise","fetch","then","abort","jsonPath","queryString","pageNum","loadImage","abortImage","removeAttribute","getImage","retries","loaded","$deferred","onload","resolve","onerror","error","resource","imgPath","Image","interpolateCSSText","text","cssText","stylesheetHTML","browser","firefox","subpx","isSubpxSupported","replace","inlineCSSRegExp","processSVGContent","destroyed","dataUrlCount","query","countInStr","MAX_DATA_URLS","match","group","cache","svgPath","processTextContent","numTextBoxes","MAX_TEXT_BOXES","textPath","processStylesheetContent","ie","$cachedPromise","cssPath","framework","createRequestWrapper","req","status","statusText","responseText","e","rawRequest","isRequestToLocalFile","urlUtil","parse","protocol","isSuccessfulStatusCode","parseOptions","method","headers","param","setHeaders","setRequestHeader","doXHR","success","fail","support","getXHR","open","onreadystatechange","readyState","send","doXDR","getXDR","ontimeout","onprogress","request","ajaxSuccess","opt","ajaxFail","appendQueryParams","isXHRSupported","isCrossDomain","isCORSSupported","retryOrFail","aborted","version","ua","navigator","userAgent","ios","test","android","blackberry","webos","kindle","exec","ielt9","ielt10","ielt11","mobile","chrome","safari","DEFAULT_PT2PX_RATIO","each","map","stringifyJSON","JSON","stringify","bisectLeft","list","x","prop","mid","low","high","Math","floor","bisectRight","clamp","a","b","sign","value","number","parseInt","array","indexOf","constrainRange","max","min","now","Date","getTime","throttle","wait","later","previous","timeout","result","context","remaining","arguments","clearTimeout","setTimeout","debounce","last","timestamp","insertCSS","styleEl","createElement","cssTextNode","createTextNode","err","getElementsByTagName","appendCSSRule","sheet","selector","rule","index","insertRule","cssRules","addRule","rules","deleteCSSRule","deleteRule","removeRule","getSelectedNode","node","sel","range","getSelection","rangeCount","getRangeAt","collapsed","anchorNode","parentNode","selection","createRange","parentElement","getComputedStyle","currentStyle","calculatePtSize","style","px","testSize","div","display","position","width","removeChild","str","token","total","p","hasOwnProperty","RegExp","isSubpixelRenderingSupported","leadingWhitespace","span","TEST_SPAN_TEMPLATE","size","appendTo","fontsize1","width1","remove","fontsize2","width2","CSS_CLASS_SUBPX_FIX","subpixelRenderingIsSupported","fix","undefined","$wrap","wrap","getVendorCSSPropertyName","prop_","vendorProp","testDiv","charAt","toUpperCase","substr","prefixes","uncamel","letter","toLowerCase","xhrSupported","xhrCORSSupported","implementation","hasFeature","csstransform","csstransition","csszoom","isXDRSupported","XDomainRequest","XMLHttpRequest","ActiveXObject","ex","parsedLocation","getCurrentURL","location","href","makeAbsolute","parsedURL","hostname","port","pathname","parsed","host","hash","search","validateConfig","numPages","numpages","prepareDOM","zoomLevel","maxZoom","ptWidth","ptHeight","pxWidth","pxHeight","pt2px","dimensions","skeleton","exceptions","height","w","h","$pages","$doc","getInitialPageStatus","pageIndex","createPages","pages","start","end","links","sortPageLinks","eq","link","destination","sorted","pagenum","handleMouseUp","updateSelectedPages","$page","closest","find","has","lazyLoader","$textContainer","$viewport","parent","handleMousemove","scrollTop","downScrollPosition","clientY","downMousePosition","y","scrollLeft","clientX","handleMouseup","$window","handleMousedown","handleResize","handleScroll","handleScrollEnd","layoutClass","initState","viewportEl","dimensionsEl","state","viewportDimensions","clientWidth","clientHeight","offsetWidth","offsetHeight","zoomState","prevZoom","zoomMode","initialWidth","initialHeight","totalWidth","totalHeight","removeAttr","calculateNextZoomLevel","direction","currentZoom","isDraggable","scrollToOffset","paged","calculateZoomAutoValue","fitWidth","calculateZoomValue","fitHeight","widestPage","actualWidth","tallestPage","actualHeight","calculateCurrentPage","prev","calculateNextPage","currentPage","calculatePreviousPage","updateCurrentPage","zoomedWidth","sumWidths","zoomedHeight","totalActualHeight","docWidth","docHeight","lineHeight","base","applyZoomResize","pageState","cssRule","namespace","scale","percent","previousStyleIndex","paddingTop","paddingRight","paddingBottom","paddingLeft","getMaxY1InRow","row","Infinity","y1s","y1","updatePageStates","updateZoomLevels","sumHeights","rows","visiblePages","fullyVisiblePages","shouldNotCenter","parseZoomValue","calculateZoomMode","minZoom","applyZoom","canZoomIn","canZoomOut","updateScrollPosition","updateVisiblePages","zoomVal","nextZoom","parsedZoom","shouldUseZoomLevel","similarity","lastZoomLevel","presets","auto","sort","totalActualWidth","scrollToPage","offset","calculateScrollPositionForPage","y0","x0","calculateVisibleRange","viewportHeight","viewportWidth","viewportY0","viewportY1","viewportX0","viewportX1","lowY","highY","lowX","highX","calculateFullyVisibleRange","setCurrentPage","updateClasses","visibleRange","fullyVisibleRange","hasClass","forceUpdatePaddings","pageEl","$pageEl","rowIndex","lastY1","rightmostPageIndex","bottommostPageIndex","getAttribute","offsetLeft","offsetTop","x1","newScrollLeft","newScrollTop","ratio","presentation","twoPageMode","baseVal","updatePageMargins","updatePageClasses","margin","$precedingPage","$currentPage","secondPageWidth","currentPageWidth","currentPageHeight","secondPage","paddingH","marginLeft","marginTop","next","buffer","z","vertical","prevPageIndex","currentPageIndex","nextRow","prevRow","calculateRange","pageLoadRange","currentIndex","layoutState","pageLoadLoop","pageLoadTID","pageLoadQueue","loadPage","pageIsLoading","stopPageLoadLoop","startPageLoadLoop","pageLoadingStopped","pushPageLoadQueue","clearPageLoadQueue","indexInRange","rangeLength","shouldLoadPage","pageIsVisible","shouldUnloadPage","queuePagesToLoadInOrder","increment","queuePageToLoad","pagefocusTriggerLoadingTID","readyTriggerLoadingTID","scrollDirection","handleBeforeZoom","handlePageAvailable","handlePageFocus","handleReady","handleZoom","pageComponents","cancelAllLoading","updateLayoutState","loadNecessaryPages","loadVisiblePages","loadPagesInRange","preload","callback","when","always","unloadPage","unload","unloadUnnecessaryPages","l","upto","$img","$loadImgPromise","imageLoaded","removeOnUnload","empty","prepare","done","createLink","$link","bbox","attr","handleClick","uri","encodeURI","target","targetEl","createLinks","createSVGEl","embedStrategy","btoa","prepareSVGContainer","$svg","svgLoaded","$svgLayer","loadSVGText","fixUseElements","contentDocument","useEls","querySelectorAll","forEach","use","image","querySelector","cloneNode","replaceChild","embedSVG","dataURLPrefix","contentWindow","defaultView","innerHTML","head","script","proxySVG","insertBefore","firstChild","append","src","encodeURIComponent","loadSVGSuccess","unloaded","$loadSVGPromise","loadSVGFail","viewerConfig","shouldUseTextLayer","loadTextLayerHTMLSuccess","doc","textEl","createHTMLDocument","$textLayer","loadTextLayerHTMLFail","loadTextLayerHTML","$loadTextPromise","enable","disable","pageText","pageContent","pageLinks","isVisible","loadRequested","$text","$links","pageComponent","currentOffsetWidth","currentOffsetHeight","currentClientWidth","currentClientHeight","initResizer","$iframe","$div","add","opacity","visiblility","border","prependTo","element","checkResize","newOffsetHeight","newOffsetWidth","inIframe","frameWidth","innerWidth","FULLSCREENCHANGE_EVENT","$document","buildEventData","scrollingStarted","ghostScrollStart","scrollendTID","SCROLL_END_TIMEOUT","fireScroll","handleTouchstart","touchStarted","touchEnded","touchMoved","handleTouchmove","handleTouchend","touchEndTime","ghostScroll","GHOST_SCROLL_TIMEOUT","GHOST_SCROLL_INTERVAL","SCROLL_EVENT_THROTTLE_INTERVAL","setCSSFlags","initViewerHTML","initPlugins","plugin","completeInit","scroller","resizer","controller","handleLinkClick","updateDragger","dragger","validateQueryParams","stylesheetEl","$assetsPromise","cls","layoutMode","newLayout","lastPage","lastZoom","previousLayoutMode","currentLayout","previousLayout","$loadStylesheetPromise","$loadMetadataPromise","$pageOneContentPromise","$pageOneTextPromise","styleSheet"],"mappings":"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","file":"crocodoc.viewer.min.js","sourcesContent":["/*! Crocodoc Viewer - v0.10.6 | (c) 2015 Box */\n\n(function (window) {\n    /*global jQuery*/\n    /*jshint unused:false, undef:false*/\n    'use strict';\n    window.Crocodoc = (function(fn) {\n        if (typeof exports === 'object') {\n            // nodejs / browserify - export a function that accepts a jquery impl\n            module.exports = fn;\n        } else {\n            // normal browser environment\n            return fn(jQuery);\n        }\n    }(function($) {\n\nvar CSS_CLASS_PREFIX         = 'crocodoc-',\n    ATTR_SVG_VERSION         = 'data-svg-version',\n    CSS_CLASS_VIEWER         = CSS_CLASS_PREFIX + 'viewer',\n    CSS_CLASS_DOC            = CSS_CLASS_PREFIX + 'doc',\n    CSS_CLASS_VIEWPORT       = CSS_CLASS_PREFIX + 'viewport',\n    CSS_CLASS_LOGO           = CSS_CLASS_PREFIX + 'viewer-logo',\n    CSS_CLASS_DRAGGABLE      = CSS_CLASS_PREFIX + 'draggable',\n    CSS_CLASS_DRAGGING       = CSS_CLASS_PREFIX + 'dragging',\n    CSS_CLASS_TEXT_SELECTED  = CSS_CLASS_PREFIX + 'text-selected',\n    CSS_CLASS_TEXT_DISABLED  = CSS_CLASS_PREFIX + 'text-disabled',\n    CSS_CLASS_LINKS_DISABLED = CSS_CLASS_PREFIX + 'links-disabled',\n    CSS_CLASS_MOBILE         = CSS_CLASS_PREFIX + 'mobile',\n    CSS_CLASS_IELT9          = CSS_CLASS_PREFIX + 'ielt9',\n    CSS_CLASS_SUPPORTS_SVG   = CSS_CLASS_PREFIX + 'supports-svg',\n    CSS_CLASS_WINDOW_AS_VIEWPORT = CSS_CLASS_PREFIX + 'window-as-viewport',\n    CSS_CLASS_LAYOUT_PREFIX  = CSS_CLASS_PREFIX + 'layout-',\n    CSS_CLASS_CURRENT_PAGE   = CSS_CLASS_PREFIX + 'current-page',\n    CSS_CLASS_PRECEDING_PAGE = CSS_CLASS_PREFIX + 'preceding-page',\n    CSS_CLASS_PAGE           = CSS_CLASS_PREFIX + 'page',\n    CSS_CLASS_PAGE_INNER     = CSS_CLASS_PAGE + '-inner',\n    CSS_CLASS_PAGE_CONTENT   = CSS_CLASS_PAGE + '-content',\n    CSS_CLASS_PAGE_SVG       = CSS_CLASS_PAGE + '-svg',\n    CSS_CLASS_PAGE_TEXT      = CSS_CLASS_PAGE + '-text',\n    CSS_CLASS_PAGE_LINK      = CSS_CLASS_PAGE + '-link',\n    CSS_CLASS_PAGE_LINKS     = CSS_CLASS_PAGE + '-links',\n    CSS_CLASS_PAGE_AUTOSCALE = CSS_CLASS_PAGE + '-autoscale',\n    CSS_CLASS_PAGE_LOADING   = CSS_CLASS_PAGE + '-loading',\n    CSS_CLASS_PAGE_ERROR     = CSS_CLASS_PAGE + '-error',\n    CSS_CLASS_PAGE_VISIBLE   = CSS_CLASS_PAGE + '-visible',\n    CSS_CLASS_PAGE_AUTOSCALE = CSS_CLASS_PAGE + '-autoscale',\n    CSS_CLASS_PAGE_PREV      = CSS_CLASS_PAGE + '-prev',\n    CSS_CLASS_PAGE_NEXT      = CSS_CLASS_PAGE + '-next',\n    CSS_CLASS_PAGE_BEFORE    = CSS_CLASS_PAGE + '-before',\n    CSS_CLASS_PAGE_AFTER     = CSS_CLASS_PAGE + '-after',\n    CSS_CLASS_PAGE_BEFORE_BUFFER = CSS_CLASS_PAGE + '-before-buffer',\n    CSS_CLASS_PAGE_AFTER_BUFFER  = CSS_CLASS_PAGE + '-after-buffer',\n    PRESENTATION_CSS_CLASSES = [\n        CSS_CLASS_PAGE_NEXT,\n        CSS_CLASS_PAGE_AFTER,\n        CSS_CLASS_PAGE_PREV,\n        CSS_CLASS_PAGE_BEFORE,\n        CSS_CLASS_PAGE_BEFORE_BUFFER,\n        CSS_CLASS_PAGE_AFTER_BUFFER\n    ].join(' ');\n\n\nvar VIEWER_HTML_TEMPLATE =\n    '<div tabindex=\"-1\" class=\"' + CSS_CLASS_VIEWPORT + '\">' +\n        '<div class=\"' + CSS_CLASS_DOC + '\"></div>' +\n    '</div>' +\n    '<div class=\"' + CSS_CLASS_LOGO + '\"></div>';\n\nvar PAGE_HTML_TEMPLATE =\n    '<div class=\"' + CSS_CLASS_PAGE + ' ' + CSS_CLASS_PAGE_LOADING + '\" ' +\n        'style=\"width:{{w}}px; height:{{h}}px;\" data-width=\"{{w}}\" data-height=\"{{h}}\">' +\n        '<div class=\"' + CSS_CLASS_PAGE_INNER + '\">' +\n            '<div class=\"' + CSS_CLASS_PAGE_CONTENT + '\">' +\n                '<div class=\"' + CSS_CLASS_PAGE_SVG + '\"></div>' +\n                '<div class=\"' + CSS_CLASS_PAGE_AUTOSCALE + '\">' +\n                    '<div class=\"' + CSS_CLASS_PAGE_TEXT + '\"></div>' +\n                    '<div class=\"' + CSS_CLASS_PAGE_LINKS + '\"></div>' +\n                '</div>' +\n            '</div>' +\n        '</div>' +\n    '</div>';\n\n// the width to consider the 100% zoom level; zoom levels are calculated based\n// on this width relative to the actual document width\nvar DOCUMENT_100_PERCENT_WIDTH = 1024;\n\n\nvar ZOOM_FIT_WIDTH = 'fitwidth',\n    ZOOM_FIT_HEIGHT = 'fitheight',\n    ZOOM_AUTO = 'auto',\n    ZOOM_IN = 'in',\n    ZOOM_OUT = 'out',\n\n    SCROLL_PREVIOUS = 'previous',\n    SCROLL_NEXT = 'next',\n\n    LAYOUT_VERTICAL = 'vertical',\n    LAYOUT_VERTICAL_SINGLE_COLUMN = 'vertical-single-column',\n    LAYOUT_HORIZONTAL = 'horizontal',\n    LAYOUT_PRESENTATION = 'presentation',\n    LAYOUT_PRESENTATION_TWO_PAGE = 'presentation-two-page',\n    LAYOUT_TEXT = 'text',\n\n    PAGE_STATUS_CONVERTING = 'converting',\n    PAGE_STATUS_NOT_LOADED = 'not loaded',\n    PAGE_STATUS_LOADING = 'loading',\n    PAGE_STATUS_LOADED = 'loaded',\n    PAGE_STATUS_ERROR = 'error';\n\n\nvar STYLE_PADDING_PREFIX = 'padding-',\n    STYLE_PADDING_TOP = STYLE_PADDING_PREFIX + 'top',\n    STYLE_PADDING_RIGHT = STYLE_PADDING_PREFIX + 'right',\n    STYLE_PADDING_LEFT = STYLE_PADDING_PREFIX + 'left',\n    STYLE_PADDING_BOTTOM = STYLE_PADDING_PREFIX + 'bottom',\n    // threshold for removing similar zoom levels (closer to 1 is more similar)\n    ZOOM_LEVEL_SIMILARITY_THRESHOLD = 0.95,\n    // threshold for removing similar zoom presets (e.g., auto, fit-width, etc)\n    ZOOM_LEVEL_PRESETS_SIMILARITY_THRESHOLD = 0.99;\n\n\nvar PAGE_LOAD_INTERVAL = 100, //ms between initiating page loads\n    MAX_PAGE_LOAD_RANGE = 32,\n    MAX_PAGE_LOAD_RANGE_MOBILE = 8,\n    // the delay in ms to wait before triggering preloading after `ready`\n    READY_TRIGGER_PRELOADING_DELAY = 1000;\n\n/**\n * Creates a global method for loading svg text into the proxy svg object\n * @NOTE: this function should never be called directly in this context;\n * it's converted to a string and encoded into the proxy svg data:url\n * @returns {void}\n * @private\n */\nfunction PROXY_SVG() {\n    'use strict';\n    window.loadSVG = function (svgText) {\n        var domParser = new window.DOMParser(),\n            svgDoc = domParser.parseFromString(svgText, 'image/svg+xml'),\n            svgEl = document.importNode(svgDoc.documentElement, true);\n        // make sure the svg width/height are explicity set to 100%\n        svgEl.setAttribute('width', '100%');\n        svgEl.setAttribute('height', '100%');\n\n        if (document.body) {\n            document.body.appendChild(svgEl);\n        } else {\n            document.documentElement.appendChild(svgEl);\n        }\n    };\n}\n\n// @NOTE: MAX_DATA_URLS is the maximum allowed number of data-urls in svg\n// content before we give up and stop rendering them\nvar SVG_MIME_TYPE = 'image/svg+xml',\n    HTML_TEMPLATE = '<style>html,body{width:100%;height:100%;margin:0;overflow:hidden;}</style>',\n    SVG_CONTAINER_TEMPLATE = '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><script><![CDATA[('+PROXY_SVG+')()]]></script></svg>',\n\n    // Embed the svg in an iframe (initialized to about:blank), and inject\n    // the SVG directly to the iframe window using document.write()\n    // @NOTE: this breaks images in Safari because [?]\n    EMBED_STRATEGY_IFRAME_INNERHTML = 1,\n\n    // Embed the svg with a data-url\n    // @NOTE: ff allows direct script access to objects embedded with a data url,\n    //        and this method prevents a throbbing spinner because document.write\n    //        causes a spinner in ff\n    // @NOTE: NOT CURRENTLY USED - this breaks images in firefox because:\n    //        https://bugzilla.mozilla.org/show_bug.cgi?id=922433\n    EMBED_STRATEGY_DATA_URL = 2,\n\n    // Embed the svg directly in html via inline svg.\n    // @NOTE: NOT CURRENTLY USED -  seems to be slow everywhere, but I'm keeping\n    //        this here because it's very little extra code, and inline SVG might\n    //        be better some day?\n    EMBED_STRATEGY_INLINE_SVG = 3,\n\n    // Embed the svg directly with an object tag; don't replace linked resources\n    // @NOTE: NOT CURRENTLY USED - this is only here for testing purposes, because\n    //        it works in every browser; it doesn't support query string params\n    //        and causes a spinner\n    EMBED_STRATEGY_BASIC_OBJECT = 4,\n\n    // Embed the svg directly with an img tag; don't replace linked resources\n    // @NOTE: NOT CURRENTLY USED - this is only here for testing purposes\n    EMBED_STRATEGY_BASIC_IMG = 5,\n\n    // Embed a proxy svg script as an object tag via data:url, which exposes a\n    // loadSVG method on its contentWindow, then call the loadSVG method directly\n    // with the svg text as the argument\n    // @NOTE: only works in firefox because of its security policy on data:uri\n    EMBED_STRATEGY_DATA_URL_PROXY = 6,\n\n    // Embed in a way similar to the EMBED_STRATEGY_DATA_URL_PROXY, but in this\n    // method we use an iframe initialized to about:blank and embed the proxy\n    // script before calling loadSVG on the iframe's contentWindow\n    // @NOTE: this is a workaround for the image issue with EMBED_STRATEGY_IFRAME_INNERHTML\n    //        in safari; it also works in firefox\n    EMBED_STRATEGY_IFRAME_PROXY = 7,\n\n    // Embed in an img tag via data:url, downloading stylesheet separately, and\n    // injecting it into the data:url of SVG text before embedding\n    // @NOTE: this method seems to be more performant on IE\n    EMBED_STRATEGY_DATA_URL_IMG = 8;\n\n/*jshint unused:false*/\n\nif (typeof $ === 'undefined') {\n    throw new Error('jQuery is required');\n}\n\n/**\n * The one global object for Crocodoc JavaScript.\n * @namespace\n */\nvar Crocodoc = (function () {\n\n    'use strict';\n\n    var components = {},\n        utilities = {};\n\n    /**\n     * Find circular dependencies in component mixins\n     * @param   {string} componentName   The component name that is being added\n     * @param   {Array} dependencies  Array of component mixin dependencies\n     * @param   {void} path           String used to keep track of depencency graph\n     * @returns {void}\n     */\n    function findCircularDependencies(componentName, dependencies, path) {\n        var i;\n        path = path || componentName;\n        for (i = 0; i < dependencies.length; ++i) {\n            if (componentName === dependencies[i]) {\n                throw new Error('Circular dependency detected: ' + path + '->' + dependencies[i]);\n            } else if (components[dependencies[i]]) {\n                findCircularDependencies(componentName, components[dependencies[i]].mixins, path + '->' + dependencies[i]);\n            }\n        }\n    }\n\n    return {\n        // Zoom, scroll, page status, layout constants\n        ZOOM_FIT_WIDTH:                 ZOOM_FIT_WIDTH,\n        ZOOM_FIT_HEIGHT:                ZOOM_FIT_HEIGHT,\n        ZOOM_AUTO:                      ZOOM_AUTO,\n        ZOOM_IN:                        ZOOM_IN,\n        ZOOM_OUT:                       ZOOM_OUT,\n\n        SCROLL_PREVIOUS:                SCROLL_PREVIOUS,\n        SCROLL_NEXT:                    SCROLL_NEXT,\n\n        LAYOUT_VERTICAL:                LAYOUT_VERTICAL,\n        LAYOUT_VERTICAL_SINGLE_COLUMN:  LAYOUT_VERTICAL_SINGLE_COLUMN,\n        LAYOUT_HORIZONTAL:              LAYOUT_HORIZONTAL,\n        LAYOUT_PRESENTATION:            LAYOUT_PRESENTATION,\n        LAYOUT_PRESENTATION_TWO_PAGE:   LAYOUT_PRESENTATION_TWO_PAGE,\n        LAYOUT_TEXT:                    LAYOUT_TEXT,\n\n        // The number of times to retry loading an asset before giving up\n        ASSET_REQUEST_RETRIES: 1,\n\n        // templates exposed to allow more customization\n        viewerTemplate: VIEWER_HTML_TEMPLATE,\n        pageTemplate: PAGE_HTML_TEMPLATE,\n\n        // exposed for testing purposes only\n        // should not be accessed directly otherwise\n        components: components,\n        utilities: utilities,\n\n        /**\n         * Create and return a viewer instance initialized with the given parameters\n         * @param {string|Element|jQuery} el The element to bind the viewer to\n         * @param {Object} config            The viewer configuration parameters\n         * @returns {Object}                 The viewer instance\n         */\n        createViewer: function (el, config) {\n            return new Crocodoc.Viewer(el, config);\n        },\n\n        /**\n         * Get a viewer instance by id\n         * @param {number} id   The id\n         * @returns {Object}    The viewer instance\n         */\n        getViewer: function (id) {\n            return Crocodoc.Viewer.get(id);\n        },\n\n        /**\n         * Register a new component\n         * @param  {string} name      The (unique) name of the component\n         * @param  {Array} mixins     Array of component names to instantiate and pass as mixinable objects to the creator method\n         * @param  {Function} creator Factory function used to create an instance of the component\n         * @returns {void}\n         */\n        addComponent: function (name, mixins, creator) {\n            if (mixins instanceof Function) {\n                creator = mixins;\n                mixins = [];\n            }\n            // make sure this component won't cause a circular mixin dependency\n            findCircularDependencies(name, mixins);\n            components[name] = {\n                mixins: mixins,\n                creator: creator\n            };\n        },\n\n        /**\n         * Create and return an instance of the named component\n         * @param  {string} name The name of the component to create\n         * @param  {Crocodoc.Scope} scope The scope object to create the component on\n         * @returns {?Object}     The component instance or null if the component doesn't exist\n         */\n        createComponent: function (name, scope) {\n            var component = components[name];\n\n            if (component) {\n                var args = [];\n                for (var i = 0; i < component.mixins.length; ++i) {\n                    args.push(this.createComponent(component.mixins[i], scope));\n                }\n                args.unshift(scope);\n                return component.creator.apply(component.creator, args);\n            }\n\n            return null;\n        },\n\n        /**\n         * Register a new Crocodoc plugin\n         * @param  {string} name      The (unique) name of the plugin\n         * @param  {Function} creator Factory function used to create an instance of the plugin\n         * @returns {void}\n         */\n        addPlugin: function (name, creator) {\n            this.addComponent('plugin-' + name, creator);\n        },\n\n        /**\n         * Register a new Crocodoc data provider\n         * @param {string} modelName The model name this data provider provides\n         * @param {Function} creator Factory function used to create an instance of the data provider.\n         */\n        addDataProvider: function(modelName, creator) {\n            this.addComponent('data-provider-' + modelName, creator);\n        },\n\n        /**\n         * Register a new utility\n         * @param  {string} name    The (unique) name of the utility\n         * @param  {Function} creator Factory function used to create an instance of the utility\n         * @returns {void}\n         */\n        addUtility: function (name, creator) {\n            utilities[name] = {\n                creator: creator,\n                instance: null\n            };\n        },\n\n        /**\n         * Retrieve the named utility\n         * @param {string} name The name of the utility to retrieve\n         * @returns {?Object}    The utility or null if the utility doesn't exist\n         */\n        getUtility: function (name) {\n            var utility = utilities[name];\n\n            if (utility) {\n                if (!utility.instance) {\n                    utility.instance = utility.creator(this);\n                }\n\n                return utility.instance;\n            }\n\n            return null;\n        }\n    };\n})();\n\n(function () {\n\n    'use strict';\n\n    /**\n     * Scope class used for component scoping (creating, destroying, broadcasting messages)\n     * @constructor\n     */\n    Crocodoc.Scope = function Scope(config) {\n\n        //----------------------------------------------------------------------\n        // Private\n        //----------------------------------------------------------------------\n\n        var util = Crocodoc.getUtility('common');\n\n        var instances = [],\n            messageQueue = [],\n            dataProviders = {},\n            ready = false;\n\n        /**\n         * Broadcast a message to all components in this scope that have registered\n         * a listener for the named message type\n         * @param  {string} messageName The message name\n         * @param  {any} data The message data\n         * @returns {void}\n         * @private\n         */\n        function broadcast(messageName, data) {\n            var i, len, instance, messages;\n            for (i = 0, len = instances.length; i < len; ++i) {\n                instance = instances[i];\n                if (!instance) {\n                    continue;\n                }\n                messages = instance.messages || [];\n\n                if (util.inArray(messageName, messages) !== -1) {\n                    if (util.isFn(instance.onmessage)) {\n                        instance.onmessage.call(instance, messageName, data);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Broadcasts any (pageavailable) messages that were queued up\n         * before the viewer was ready\n         * @returns {void}\n         * @private\n         */\n        function broadcastQueuedMessages() {\n            var message;\n            while (messageQueue.length) {\n                message = messageQueue.shift();\n                broadcast(message.name, message.data);\n            }\n            messageQueue = null;\n        }\n\n        /**\n         * Call the destroy method on a component instance if it exists and the\n         * instance has not already been destroyed\n         * @param   {Object} instance The component instance\n         * @returns {void}\n         */\n        function destroyComponent(instance) {\n            if (util.isFn(instance.destroy) && !instance._destroyed) {\n                instance.destroy();\n                instance._destroyed = true;\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        config.dataProviders = config.dataProviders || {};\n\n        /**\n         * Create and return an instance of the named component,\n         * and add it to the list of instances in this scope\n         * @param  {string} componentName The name of the component to create\n         * @returns {?Object}     The component instance or null if the component doesn't exist\n         */\n        this.createComponent = function (componentName) {\n            var instance = Crocodoc.createComponent(componentName, this);\n            if (instance) {\n                instance.componentName = componentName;\n                instances.push(instance);\n            }\n            return instance;\n        };\n\n        /**\n         * Remove and call the destroy method on a component instance\n         * @param  {Object} instance The component instance to remove\n         * @returns {void}\n         */\n        this.destroyComponent = function (instance) {\n            var i, len;\n\n            for (i = 0, len = instances.length; i < len; ++i) {\n                if (instance === instances[i]) {\n                    destroyComponent(instance);\n                    instances.splice(i, 1);\n                    break;\n                }\n            }\n        };\n\n        /**\n         * Remove and call the destroy method on all instances in this scope\n         * @returns {void}\n         */\n        this.destroy = function () {\n            var i, len, instance,\n                components = instances.slice();\n\n            for (i = 0, len = components.length; i < len; ++i) {\n                instance = components[i];\n                destroyComponent(instance);\n            }\n            instances = [];\n            dataProviders = {};\n        };\n\n        /**\n         * Broadcast a message or queue it until the viewer is ready\n         * @param   {string} name The name of the message\n         * @param   {*} data The message data\n         * @returns {void}\n         */\n        this.broadcast = function (messageName, data) {\n            if (ready) {\n                broadcast(messageName, data);\n            } else {\n                messageQueue.push({ name: messageName, data: data });\n            }\n        };\n\n        /**\n         * Passthrough method to the framework that retrieves utilities.\n         * @param {string} name The name of the utility to retrieve\n         * @returns {?Object}    An object if the utility is found or null if not\n         */\n        this.getUtility = function (name) {\n            return Crocodoc.getUtility(name);\n        };\n\n        /**\n         * Get the config object associated with this scope\n         * @returns {Object} The config object\n         */\n        this.getConfig = function () {\n            return config;\n        };\n\n        /**\n         * Tell the scope that the viewer is ready and broadcast queued messages\n         * @returns {void}\n         */\n        this.ready = function () {\n            if (!ready) {\n                ready = true;\n                broadcastQueuedMessages();\n            }\n        };\n\n        /**\n         * Get a model object from a data provider. If the objectType is listed\n         * in config.dataProviders, this will get the value from the data\n         * provider that is specified in that map instead.\n         * @param {string} objectType The type of object to retrieve ('page-svg', 'page-text', etc)\n         * @param {string} objectKey  The key of the object to retrieve\n         * @returns {$.Promise}\n         */\n        this.get = function(objectType, objectKey) {\n            var newObjectType = config.dataProviders[objectType] || objectType;\n\n            var provider = this.getDataProvider(newObjectType);\n            if (provider) {\n                return provider.get(objectType, objectKey);\n            }\n            return $.Deferred().reject('data-provider not found').promise();\n        };\n\n        /**\n         * Get an instance of a data provider. Ignores config.dataProviders\n         * overrides.\n         * @param {string} objectType The type of object to retrieve a data provider for ('page-svg', 'page-text', etc)\n         * @returns {Object} The data provider\n         */\n        this.getDataProvider = function (objectType) {\n            var provider;\n            if (dataProviders[objectType]) {\n                provider = dataProviders[objectType];\n            } else {\n                provider = this.createComponent('data-provider-' + objectType);\n                dataProviders[objectType] = provider;\n            }\n\n            return provider;\n        };\n    };\n})();\n\n(function () {\n    'use strict';\n\n    /**\n     * Build an event object for the given type and data\n     * @param   {string} type The event type\n     * @param   {Object} data The event data\n     * @returns {Object}      The event object\n     */\n    function buildEventObject(type, data) {\n        var isDefaultPrevented = false;\n        return {\n            type: type,\n            data: data,\n\n            /**\n             * Prevent the default action for this event\n             * @returns {void}\n             */\n            preventDefault: function () {\n                isDefaultPrevented = true;\n            },\n\n            /**\n             * Return true if preventDefault() has been called on this event\n             * @returns {Boolean}\n             */\n            isDefaultPrevented: function () {\n                return isDefaultPrevented;\n            }\n        };\n    }\n\n    /**\n     * An object that is capable of generating custom events and also\n     * executing handlers for events when they occur.\n     * @constructor\n     */\n    Crocodoc.EventTarget = function() {\n\n        /**\n         * Map of events to handlers. The keys in the object are the event names.\n         * The values in the object are arrays of event handler functions.\n         * @type {Object}\n         * @private\n         */\n        this._handlers = {};\n    };\n\n    Crocodoc.EventTarget.prototype = {\n\n        // restore constructor\n        constructor: Crocodoc.EventTarget,\n\n        /**\n         * Adds a new event handler for a particular type of event.\n         * @param {string} type The name of the event to listen for.\n         * @param {Function} handler The function to call when the event occurs.\n         * @returns {void}\n         */\n        on: function(type, handler) {\n            if (typeof this._handlers[type] === 'undefined') {\n                this._handlers[type] = [];\n            }\n\n            this._handlers[type].push(handler);\n        },\n\n        /**\n         * Fires an event with the given name and data.\n         * @param {string} type The type of event to fire.\n         * @param {Object} data An object with properties that should end up on\n         *      the event object for the given event.\n         * @returns {Object} The event object\n         */\n        fire: function(type, data) {\n            var handlers,\n                i,\n                len,\n                event = buildEventObject(type, data);\n\n            // if there are handlers for the event, call them in order\n            handlers = this._handlers[event.type];\n            if (handlers instanceof Array) {\n                // @NOTE: do a concat() here to create a copy of the handlers array,\n                // so that if another handler is removed of the same type, it doesn't\n                // interfere with the handlers array\n                handlers = handlers.concat();\n                for (i = 0, len = handlers.length; i < len; i++) {\n                    if (handlers[i]) {\n                        handlers[i].call(this, event);\n                    }\n                }\n            }\n\n            // call handlers for `all` event type\n            handlers = this._handlers.all;\n            if (handlers instanceof Array) {\n                // @NOTE: do a concat() here to create a copy of the handlers array,\n                // so that if another handler is removed of the same type, it doesn't\n                // interfere with the handlers array\n                handlers = handlers.concat();\n                for (i = 0, len = handlers.length; i < len; i++) {\n                    if (handlers[i]) {\n                        handlers[i].call(this, event);\n                    }\n                }\n            }\n\n            return event;\n        },\n\n        /**\n         * Removes an event handler from a given event.\n         * If the handler is not provided, remove all handlers of the given type.\n         * @param {string} type The name of the event to remove from.\n         * @param {Function} handler The function to remove as a handler.\n         * @returns {void}\n         */\n        off: function(type, handler) {\n            var handlers = this._handlers[type],\n                i,\n                len;\n\n            if (handlers instanceof Array) {\n                if (!handler) {\n                    handlers.length = 0;\n                    return;\n                }\n                for (i = 0, len = handlers.length; i < len; i++) {\n                    if (handlers[i] === handler || handlers[i].handler === handler) {\n                        handlers.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n        },\n\n\n        /**\n         * Adds a new event handler that should be removed after it's been triggered once.\n         * @param {string} type The name of the event to listen for.\n         * @param {Function} handler The function to call when the event occurs.\n         * @returns {void}\n         */\n        one: function(type, handler) {\n            var self = this,\n                proxy = function (event) {\n                    self.off(type, proxy);\n                    handler.call(self, event);\n                };\n            proxy.handler = handler;\n            this.on(type, proxy);\n        }\n    };\n\n})();\n\n/**\n * The Crocodoc.Viewer namespace\n * @namespace\n */\n(function () {\n    'use strict';\n\n    var viewerInstanceCount = 0,\n        instances = {};\n\n    /**\n     * Crocodoc.Viewer constructor\n     * @param {jQuery|string|Element} el The element to wrap\n     * @param {Object} options           Configuration options\n     * @constructor\n     */\n    Crocodoc.Viewer = function (el, options) {\n        // call the EventTarget constructor to init handlers\n        Crocodoc.EventTarget.call(this);\n\n        var util = Crocodoc.getUtility('common');\n        var layout,\n            $el = $(el),\n            config = util.extend(true, {}, Crocodoc.Viewer.defaults, options),\n            scope = new Crocodoc.Scope(config),\n            viewerBase = scope.createComponent('viewer-base');\n\n        //Container exists?\n        if ($el.length === 0) {\n            throw new Error('Invalid container element');\n        }\n\n        this.id = config.id = ++viewerInstanceCount;\n        config.api = this;\n        config.$el = $el;\n        // register this instance\n        instances[this.id] = this;\n\n        function init() {\n            viewerBase.init();\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        /**\n         * Destroy the viewer instance\n         * @returns {void}\n         */\n        this.destroy = function () {\n            // unregister this instance\n            delete instances[config.id];\n\n            // broadcast a destroy message\n            scope.broadcast('destroy');\n\n            // destroy all components and plugins in this scope\n            scope.destroy();\n        };\n\n        /**\n         * Intiate loading of document assets\n         * @returns {void}\n         */\n        this.load = function () {\n            viewerBase.loadAssets();\n        };\n\n        /**\n         * Set the layout to the given mode, destroying and cleaning up the current\n         * layout if there is one\n         * @param  {string} mode The layout mode\n         * @returns {void}\n         */\n        this.setLayout = function (mode) {\n            // removing old reference to prevent errors when handling layoutchange message\n            layout = null;\n            layout = viewerBase.setLayout(mode);\n        };\n\n        /**\n         * Zoom to the given value\n         * @param  {float|string} val Numeric zoom level to zoom to or one of:\n         *                            Crocodoc.ZOOM_IN\n         *                            Crocodoc.ZOOM_OUT\n         *                            Crocodoc.ZOOM_AUTO\n         *                            Crocodoc.ZOOM_FIT_WIDTH\n         *                            Crocodoc.ZOOM_FIT_HEIGHT\n         * @returns {void}\n         */\n        this.zoom = function (val) {\n            // adjust for page scale if passed value is a number\n            var valFloat = parseFloat(val);\n            if (layout) {\n                if (valFloat) {\n                    val = valFloat / (config.pageScale || 1);\n                }\n                layout.setZoom(val);\n            }\n        };\n\n        /**\n         * Scroll to the given page\n         * @TODO: rename to scrollToPage when possible (and remove this for non-\n         * page-based viewers)\n         * @param  {int|string} page Page number or one of:\n         *                           Crocodoc.SCROLL_PREVIOUS\n         *                           Crocodoc.SCROLL_NEXT\n         * @returns {void}\n         */\n        this.scrollTo = function (page) {\n            if (layout && util.isFn(layout.scrollTo)) {\n                layout.scrollTo(page);\n            }\n        };\n\n        /**\n         * Scrolls by the given pixel amount from the current location\n         * @param  {int} left Left offset to scroll to\n         * @param  {int} top  Top offset to scroll to\n         * @returns {void}\n         */\n        this.scrollBy = function (left, top) {\n            if (layout) {\n                layout.scrollBy(left, top);\n            }\n        };\n\n        /**\n         * Focuses the viewport so it can be natively scrolled with the keyboard\n         * @returns {void}\n         */\n        this.focus = function () {\n            if (layout) {\n                layout.focus();\n            }\n        };\n\n        /**\n         * Enable text selection, loading text assets per page if necessary\n         * @returns {void}\n         */\n        this.enableTextSelection = function () {\n            $el.toggleClass(CSS_CLASS_TEXT_DISABLED, false);\n            if (!config.enableTextSelection) {\n                config.enableTextSelection = true;\n                scope.broadcast('textenabledchange', { enabled: true });\n            }\n        };\n\n        /**\n         * Disable text selection, hiding text layer on pages if it's already there\n         * and disabling the loading of new text assets\n         * @returns {void}\n         */\n        this.disableTextSelection = function () {\n            $el.toggleClass(CSS_CLASS_TEXT_DISABLED, true);\n            if (config.enableTextSelection) {\n                config.enableTextSelection = false;\n                scope.broadcast('textenabledchange', { enabled: false });\n            }\n        };\n\n        /**\n         * Enable links\n         * @returns {void}\n         */\n        this.enableLinks = function () {\n            if (!config.enableLinks) {\n                $el.removeClass(CSS_CLASS_LINKS_DISABLED);\n                config.enableLinks = true;\n            }\n        };\n\n        /**\n         * Disable links\n         * @returns {void}\n         */\n        this.disableLinks = function () {\n            if (config.enableLinks) {\n                $el.addClass(CSS_CLASS_LINKS_DISABLED);\n                config.enableLinks = false;\n            }\n        };\n\n        /**\n         * Force layout update\n         * @returns {void}\n         */\n        this.updateLayout = function () {\n            if (layout) {\n                layout.update();\n            }\n        };\n\n        init();\n    };\n\n    Crocodoc.Viewer.prototype = new Crocodoc.EventTarget();\n    Crocodoc.Viewer.prototype.constructor = Crocodoc.Viewer;\n\n    /**\n     * Get a viewer instance by id\n     * @param {number} id   The id\n     * @returns {Object}    The viewer instance\n     */\n    Crocodoc.Viewer.get = function (id) {\n        return instances[id];\n    };\n\n    // Global defaults\n    Crocodoc.Viewer.defaults = {\n        // the url to load the assets from (required)\n        url: null,\n\n        // document viewer layout\n        layout: LAYOUT_VERTICAL,\n\n        // initial zoom level\n        zoom: ZOOM_AUTO,\n\n        // page to start on\n        page: 1,\n\n        // enable/disable text layer\n        enableTextSelection: true,\n\n        // enable/disable links layer\n        enableLinks: true,\n\n        // enable/disable click-and-drag\n        enableDragging: false,\n\n        // query string parameters to append to all asset requests\n        queryParams: null,\n\n        // plugin configs\n        plugins: {},\n\n        // whether to use the browser window as the viewport into the document (this\n        // is useful when the document should take up the entire browser window, e.g.,\n        // on mobile devices)\n        useWindowAsViewport: false,\n\n        //--------------------------------------------------------------------------\n        // The following are undocumented, internal, or experimental options,\n        // which are very subject to change and likely to be broken.\n        // --\n        // USE AT YOUR OWN RISK!\n        //--------------------------------------------------------------------------\n\n        // whether or not the conversion is finished (eg., pages are ready to be loaded)\n        conversionIsComplete: true,\n\n        // template for loading assets... this should rarely (if ever) change\n        template: {\n            svg: 'page-{{page}}.svg',\n            img: 'page-{{page}}.png',\n            html: 'text-{{page}}.html',\n            css: 'stylesheet.css',\n            json: 'info.json'\n        },\n\n        // default data-providers\n        dataProviders: {\n            metadata: 'metadata',\n            stylesheet: 'stylesheet',\n            'page-svg': 'page-svg',\n            'page-text': 'page-text',\n            'page-img': 'page-img'\n        },\n\n        // page to start/end on (pages outside this range will not be shown)\n        pageStart: null,\n        pageEnd: null,\n\n        // whether or not to automatically load page one assets immediately (even\n        // if conversion is not yet complete)\n        autoloadFirstPage: true,\n\n        // zoom levels are relative to the viewport size,\n        // and the dynamic zoom levels (auto, fitwidth, etc) will be added into the mix\n        zoomLevels: [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 2.0, 3.0]\n    };\n})();\n\n\nCrocodoc.addDataProvider('metadata', function(scope) {\n    'use strict';\n\n    var ajax = scope.getUtility('ajax'),\n        util = scope.getUtility('common'),\n        config = scope.getConfig();\n\n    /**\n     * Process metadata json and return the result\n     * @param   {string} json The original JSON text\n     * @returns {string}      The processed JSON text\n     * @private\n     */\n    function processJSONContent(json) {\n        return util.parseJSON(json);\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Retrieve the info.json asset from the server\n         * @returns {$.Promise} A promise with an additional abort() method that will abort the XHR request.\n         */\n        get: function() {\n            var url = this.getURL(),\n                $promise = ajax.fetch(url, Crocodoc.ASSET_REQUEST_RETRIES);\n\n            // @NOTE: promise.then() creates a new promise, which does not copy\n            // custom properties, so we need to create a futher promise and add\n            // an object with the abort method as the new target\n            return $promise.then(processJSONContent).promise({\n                abort: $promise.abort\n            });\n        },\n\n        /**\n         * Build and return the URL to the metadata JSON\n         * @returns {string}         The URL\n         */\n        getURL: function () {\n            var jsonPath = config.template.json;\n            return config.url + jsonPath + config.queryString;\n        }\n    };\n});\n\nCrocodoc.addDataProvider('page-img', function(scope) {\n    'use strict';\n\n    var util = scope.getUtility('common'),\n        config = scope.getConfig();\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Retrieve the page image asset from the server\n         * @param {string} objectType The type of data being requested\n         * @param {number} pageNum The page number for which to request the page image\n         * @returns {$.Promise}    A promise with an additional abort() method that will abort the img request.\n         */\n        get: function(objectType, pageNum) {\n            var img = this.getImage(),\n                retries = Crocodoc.ASSET_REQUEST_RETRIES,\n                loaded = false,\n                url = this.getURL(pageNum),\n                $deferred = $.Deferred();\n\n            function loadImage() {\n                img.setAttribute('src', url);\n            }\n\n            function abortImage() {\n                img.removeAttribute('src');\n            }\n\n            // add load and error handlers\n            img.onload = function () {\n                loaded = true;\n                $deferred.resolve(img);\n            };\n\n            img.onerror = function () {\n                if (retries > 0) {\n                    retries--;\n                    abortImage();\n                    loadImage();\n                } else {\n                    img = null;\n                    loaded = false;\n                    $deferred.reject({\n                        error: 'image failed to load',\n                        resource: url\n                    });\n                }\n            };\n\n            // load the image\n            loadImage();\n\n            return $deferred.promise({\n                abort: function () {\n                    if (!loaded) {\n                        abortImage();\n                        $deferred.reject();\n                    }\n                }\n            });\n        },\n\n        /**\n         * Build and return the URL to the PNG asset for the specified page\n         * @param   {number} pageNum The page number\n         * @returns {string}         The URL\n         */\n        getURL: function (pageNum) {\n            var imgPath = util.template(config.template.img, { page: pageNum });\n            return config.url + imgPath + config.queryString;\n        },\n\n        /**\n         * Create and return a new image element (used for testing purporses)\n         * @returns {Image}\n         */\n        getImage: function () {\n            return new Image();\n        }\n    };\n});\n\nCrocodoc.addDataProvider('page-svg', function(scope) {\n    'use strict';\n\n    var MAX_DATA_URLS = 1000;\n\n    var util = scope.getUtility('common'),\n        ajax = scope.getUtility('ajax'),\n        browser = scope.getUtility('browser'),\n        subpx = scope.getUtility('subpx'),\n        config = scope.getConfig(),\n        destroyed = false,\n        cache = {},\n        // NOTE: there are cases where the stylesheet link tag will be self-\n        // closing, so check for both cases\n        inlineCSSRegExp = /<xhtml:link[^>]*>(\\s*<\\/xhtml:link>)?/i;\n\n    /**\n     * Interpolate CSS text into the SVG text\n     * @param   {string} text    The SVG text\n     * @param   {string} cssText The CSS text\n     * @returns {string}         The full SVG text\n     */\n    function interpolateCSSText(text, cssText) {\n        // CSS text\n        var stylesheetHTML = '<style>' + cssText + '</style>';\n\n        // If using Firefox with no subpx support, add \"text-rendering\" CSS.\n        // @NOTE(plai): We are not adding this to Chrome because Chrome supports \"textLength\"\n        // on tspans and because the \"text-rendering\" property slows Chrome down significantly.\n        // In Firefox, we're waiting on this bug: https://bugzilla.mozilla.org/show_bug.cgi?id=890692\n        // @TODO: Use feature detection instead (textLength)\n        if (browser.firefox && !subpx.isSubpxSupported()) {\n            stylesheetHTML += '<style>text { text-rendering: geometricPrecision; }</style>';\n        }\n\n        // inline the CSS!\n        text = text.replace(inlineCSSRegExp, stylesheetHTML);\n\n        return text;\n    }\n\n    /**\n     * Process SVG text and return the embeddable result\n     * @param   {string} text The original SVG text\n     * @returns {string}      The processed SVG text\n     * @private\n     */\n    function processSVGContent(text) {\n        if (destroyed) {\n            return;\n        }\n\n        var query = config.queryString.replace('&', '&#38;'),\n            dataUrlCount;\n\n        dataUrlCount = util.countInStr(text, 'xlink:href=\"data:image');\n        // remove data:urls from the SVG content if the number exceeds MAX_DATA_URLS\n        if (dataUrlCount > MAX_DATA_URLS) {\n            // remove all data:url images that are smaller than 5KB\n            text = text.replace(/<image[\\s\\w-_=\"]*xlink:href=\"data:image\\/[^\"]{0,5120}\"[^>]*>/ig, '');\n        }\n\n        // @TODO: remove this, because we no longer use any external assets in this way\n        // modify external asset urls for absolute path\n        text = text.replace(/href=\"([^\"#:]*)\"/g, function (match, group) {\n            return 'href=\"' + config.url + group + query + '\"';\n        });\n\n        return scope.get('stylesheet').then(function (cssText) {\n            return interpolateCSSText(text, cssText);\n        });\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Retrieve a SVG asset from the server\n         * @param {string} objectType The type of data being requested\n         * @param {number} pageNum The page number for which to request the SVG\n         * @returns {$.Promise}    A promise with an additional abort() method that will abort the XHR request.\n         */\n        get: function(objectType, pageNum) {\n            var url = this.getURL(pageNum),\n                $promise;\n\n            if (cache[pageNum]) {\n                return cache[pageNum];\n            }\n\n            $promise = ajax.fetch(url, Crocodoc.ASSET_REQUEST_RETRIES);\n\n            // @NOTE: promise.then() creates a new promise, which does not copy\n            // custom properties, so we need to create a futher promise and add\n            // an object with the abort method as the new target\n            cache[pageNum] = $promise.then(processSVGContent).promise({\n                abort: function () {\n                    $promise.abort();\n                    if (cache) {\n                        delete cache[pageNum];\n                    }\n                }\n            });\n            return cache[pageNum];\n        },\n\n        /**\n         * Build and return the URL to the SVG asset for the specified page\n         * @param   {number} pageNum The page number\n         * @returns {string}         The URL\n         */\n        getURL: function (pageNum) {\n            var svgPath = util.template(config.template.svg, { page: pageNum });\n            return config.url + svgPath + config.queryString;\n        },\n\n        /**\n         * Cleanup the data-provider\n         * @returns {void}\n         */\n        destroy: function () {\n            destroyed = true;\n            util = ajax = subpx = browser = config = cache = null;\n        }\n    };\n});\n\nCrocodoc.addDataProvider('page-text', function(scope) {\n    'use strict';\n\n    var MAX_TEXT_BOXES = 256;\n\n    var util = scope.getUtility('common'),\n        ajax = scope.getUtility('ajax'),\n        config = scope.getConfig(),\n        destroyed = false,\n        cache = {};\n\n    /**\n     * Process HTML text and return the embeddable result\n     * @param   {string} text The original HTML text\n     * @returns {string}      The processed HTML text\n     * @private\n     */\n    function processTextContent(text) {\n        if (destroyed) {\n            return;\n        }\n\n        // in the text layer, divs are only used for text boxes, so\n        // they should provide an accurate count\n        var numTextBoxes = util.countInStr(text, '<div');\n        // too many textboxes... don't load this page for performance reasons\n        if (numTextBoxes > MAX_TEXT_BOXES) {\n            return '';\n        }\n\n        // remove reference to the styles\n        text = text.replace(/<link rel=\"stylesheet\".*/, '');\n\n        return text;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Retrieve a text asset from the server\n         * @param {string} objectType The type of data being requested\n         * @param {number} pageNum The page number for which to request the text HTML\n         * @returns {$.Promise}    A promise with an additional abort() method that will abort the XHR request.\n         */\n        get: function(objectType, pageNum) {\n            var url = this.getURL(pageNum),\n                $promise;\n\n            if (cache[pageNum]) {\n                return cache[pageNum];\n            }\n\n            $promise = ajax.fetch(url, Crocodoc.ASSET_REQUEST_RETRIES);\n\n            // @NOTE: promise.then() creates a new promise, which does not copy\n            // custom properties, so we need to create a futher promise and add\n            // an object with the abort method as the new target\n            cache[pageNum] = $promise.then(processTextContent).promise({\n                abort: function () {\n                    $promise.abort();\n                    if (cache) {\n                        delete cache[pageNum];\n                    }\n                }\n            });\n            return cache[pageNum];\n        },\n\n        /**\n         * Build and return the URL to the HTML asset for the specified page\n         * @param   {number} pageNum The page number\n         * @returns {string}         The URL\n         */\n        getURL: function (pageNum) {\n            var textPath = util.template(config.template.html, { page: pageNum });\n            return config.url + textPath + config.queryString;\n        },\n\n        /**\n         * Cleanup the data-provider\n         * @returns {void}\n         */\n        destroy: function () {\n            destroyed = true;\n            util = ajax = config = cache = null;\n        }\n    };\n});\n\nCrocodoc.addDataProvider('stylesheet', function(scope) {\n    'use strict';\n\n    var ajax = scope.getUtility('ajax'),\n        browser = scope.getUtility('browser'),\n        config = scope.getConfig(),\n        $cachedPromise;\n\n    /**\n     * Process stylesheet text and return the embeddable result\n     * @param   {string} text The original CSS text\n     * @returns {string}      The processed CSS text\n     * @private\n     */\n    function processStylesheetContent(text) {\n        // @NOTE: There is a bug in IE that causes the text layer to\n        // not render the font when loaded for a second time (i.e.,\n        // destroy and recreate a viewer for the same document), so\n        // namespace the font-family so there is no collision\n        if (browser.ie) {\n            text = text.replace(/font-family:[\\s\\\"\\']*([\\w-]+)\\b/g,\n                '$0-' + config.id);\n        }\n\n        return text;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Retrieve the stylesheet.css asset from the server\n         * @returns {$.Promise} A promise with an additional abort() method that will abort the XHR request.\n         */\n        get: function() {\n            if ($cachedPromise) {\n                return $cachedPromise;\n            }\n\n            var $promise = ajax.fetch(this.getURL(), Crocodoc.ASSET_REQUEST_RETRIES);\n\n            // @NOTE: promise.then() creates a new promise, which does not copy\n            // custom properties, so we need to create a futher promise and add\n            // an object with the abort method as the new target\n            $cachedPromise = $promise.then(processStylesheetContent).promise({\n                abort: function () {\n                    $promise.abort();\n                    $cachedPromise = null;\n                }\n            });\n            return $cachedPromise;\n        },\n\n        /**\n         * Build and return the URL to the stylesheet CSS\n         * @returns {string}         The URL\n         */\n        getURL: function () {\n            var cssPath = config.template.css;\n            return config.url + cssPath + config.queryString;\n        },\n\n        /**\n         * Cleanup the data-provider\n         * @returns {void}\n         */\n        destroy: function () {\n            ajax = browser = config = null;\n            $cachedPromise = null;\n        }\n    };\n});\n\nCrocodoc.addUtility('ajax', function (framework) {\n\n    'use strict';\n\n    var util = framework.getUtility('common'),\n        support = framework.getUtility('support'),\n        urlUtil = framework.getUtility('url');\n\n    /**\n     * Creates a request object to call the success/fail handlers on\n     * @param {XMLHttpRequest} req The request object to wrap\n     * @returns {Object} The request object\n     * @private\n     */\n    function createRequestWrapper(req) {\n        var status,\n            statusText,\n            responseText;\n        try {\n            status = req.status;\n            statusText = req.statusText;\n            responseText = req.responseText;\n        } catch (e) {\n            status = 0;\n            statusText = '';\n            responseText = null;\n        }\n        return {\n            status: status,\n            statusText: statusText,\n            responseText: responseText,\n            rawRequest: req\n        };\n    }\n\n    /**\n    * Returns true if the url is referencing a local file\n    * @param   {string}  url The URL\n    * @param   {Boolean}\n    */\n    function isRequestToLocalFile(url) {\n        return urlUtil.parse(url).protocol === 'file:';\n    }\n\n    /**\n     * Return true if the given status code looks successful\n     * @param   {number}  status The http status code\n     * @returns {Boolean}\n     */\n    function isSuccessfulStatusCode(status) {\n        return status >= 200 && status < 300 || status === 304;\n    }\n\n    /**\n     * Parse AJAX options\n     * @param   {Object} options The options\n     * @returns {Object}         The parsed options\n     */\n    function parseOptions(options) {\n        options = util.extend(true, {}, options || {});\n        options.method = options.method || 'GET';\n        options.headers = options.headers || [];\n        options.data = options.data || '';\n\n        if (typeof options.data !== 'string') {\n            options.data = $.param(options.data);\n            if (options.method !== 'GET') {\n                options.data = options.data;\n                options.headers.push(['Content-Type', 'application/x-www-form-urlencoded']);\n            }\n        }\n        return options;\n    }\n\n    /**\n     * Set XHR headers\n     * @param {XMLHttpRequest} req The request object\n     * @param {Array} headers      Array of headers to set\n     */\n    function setHeaders(req, headers) {\n        var i;\n        for (i = 0; i < headers.length; ++i) {\n            req.setRequestHeader(headers[i][0], headers[i][1]);\n        }\n    }\n\n    /**\n     * Make an XHR request\n     * @param   {string}   url     request URL\n     * @param   {string}   method  request method\n     * @param   {*}        data    request data to send\n     * @param   {Array}    headers request headers\n     * @param   {Function} success success callback function\n     * @param   {Function} fail    fail callback function\n     * @returns {XMLHttpRequest}   Request object\n     * @private\n     */\n    function doXHR(url, method, data, headers, success, fail) {\n        var req = support.getXHR();\n        req.open(method, url, true);\n        req.onreadystatechange = function () {\n            var status;\n            if (req.readyState === 4) { // DONE\n                // remove the onreadystatechange handler,\n                // because it could be called again\n                // @NOTE: we replace it with a noop function, because\n                // IE8 will throw an error if the value is not of type\n                // 'function' when using ActiveXObject\n                req.onreadystatechange = function () {};\n\n                try {\n                    status = req.status;\n                } catch (e) {\n                    // NOTE: IE (9?) throws an error when the request is aborted\n                    fail(req);\n                    return;\n                }\n\n                // status is 0 for successful local file requests, so assume 200\n                if (status === 0 && isRequestToLocalFile(url)) {\n                    status = 200;\n                }\n\n                if (isSuccessfulStatusCode(status)) {\n                    success(req);\n                } else {\n                    fail(req);\n                }\n            }\n        };\n        setHeaders(req, headers);\n        req.send(data);\n        return req;\n    }\n\n    /**\n     * Make an XDR request\n     * @param   {string}   url     request URL\n     * @param   {string}   method  request method\n     * @param   {*}        data    request data to send\n     * @param   {Function} success success callback function\n     * @param   {Function} fail    fail callback function\n     * @returns {XDomainRequest} Request object\n     * @private\n     */\n    function doXDR(url, method, data, success, fail) {\n        var req = support.getXDR();\n        try {\n            req.open(method, url);\n            req.onload = function () { success(req); };\n            // NOTE: IE (8/9) requires onerror, ontimeout, and onprogress\n            // to be defined when making XDR to https servers\n            req.onerror = function () { fail(req); };\n            req.ontimeout = function () { fail(req); };\n            req.onprogress = function () {};\n            req.send(data);\n        } catch (e) {\n            return fail({\n                status: 0,\n                statusText: e.message\n            });\n        }\n        return req;\n    }\n\n    return {\n        /**\n         * Make a raw AJAX request\n         * @param   {string}     url               request URL\n         * @param   {Object}     [options]         AJAX request options\n         * @param   {string}     [options.method]  request method, eg. 'GET', 'POST' (defaults to 'GET')\n         * @param   {Array}      [options.headers] request headers (defaults to [])\n         * @param   {*}          [options.data]    request data to send (defaults to null)\n         * @param   {Function}   [options.success] success callback function\n         * @param   {Function}   [options.fail]    fail callback function\n         * @returns {XMLHttpRequest|XDomainRequest} Request object\n         */\n        request: function (url, options) {\n            var opt = parseOptions(options),\n                method = opt.method,\n                data = opt.data,\n                headers = opt.headers;\n\n            if (method === 'GET' && data) {\n                url = urlUtil.appendQueryParams(url, data);\n                data = '';\n            }\n\n            /**\n             * Function to call on successful AJAX request\n             * @returns {void}\n             * @private\n             */\n            function ajaxSuccess(req) {\n                if (util.isFn(opt.success)) {\n                    opt.success.call(createRequestWrapper(req));\n                }\n                return req;\n            }\n\n            /**\n             * Function to call on failed AJAX request\n             * @returns {void}\n             * @private\n             */\n            function ajaxFail(req) {\n                if (util.isFn(opt.fail)) {\n                    opt.fail.call(createRequestWrapper(req));\n                }\n                return req;\n            }\n\n            // is XHR supported at all?\n            if (!support.isXHRSupported()) {\n                return opt.fail({\n                    status: 0,\n                    statusText: 'AJAX not supported'\n                });\n            }\n\n            // cross-domain request? check if CORS is supported...\n            if (urlUtil.isCrossDomain(url) && !support.isCORSSupported()) {\n                // the browser supports XHR, but not XHR+CORS, so (try to) use XDR\n                return doXDR(url, method, data, ajaxSuccess, ajaxFail);\n            } else {\n                // the browser supports XHR and XHR+CORS, so just do a regular XHR\n                return doXHR(url, method, data, headers, ajaxSuccess, ajaxFail);\n            }\n        },\n\n        /**\n         * Fetch an asset, retrying if necessary\n         * @param {string} url      A url for the desired asset\n         * @param {number} retries  The number of times to retry if the request fails\n         * @returns {$.Promise}     A promise with an additional abort() method that will abort the XHR request.\n         */\n        fetch: function (url, retries) {\n            var req,\n                aborted = false,\n                ajax = this,\n                $deferred = $.Deferred();\n\n            /**\n             * If there are retries remaining, make another attempt, otherwise\n             * give up and reject the deferred\n             * @param   {Object} error The error object\n             * @returns {void}\n             * @private\n             */\n            function retryOrFail(error) {\n                if (retries > 0) {\n                    // if we have retries remaining, make another request\n                    retries--;\n                    req = request();\n                } else {\n                    // finally give up\n                    $deferred.reject(error);\n                }\n            }\n\n            /**\n             * Make an AJAX request for the asset\n             * @returns {XMLHttpRequest|XDomainRequest} Request object\n             * @private\n             */\n            function request() {\n                return ajax.request(url, {\n                    success: function () {\n                        if (!aborted) {\n                            if (this.responseText) {\n                                $deferred.resolve(this.responseText);\n                            } else {\n                                // the response was empty, so consider this a\n                                // failed request\n                                retryOrFail({\n                                    error: 'empty response',\n                                    status: this.status,\n                                    resource: url\n                                });\n                            }\n                        }\n                    },\n                    fail: function () {\n                        if (!aborted) {\n                            retryOrFail({\n                                error: this.statusText,\n                                status: this.status,\n                                resource: url\n                            });\n                        }\n                    }\n                });\n            }\n\n            req = request();\n            return $deferred.promise({\n                abort: function() {\n                    aborted = true;\n                    req.abort();\n                }\n            });\n        }\n    };\n});\n\nCrocodoc.addUtility('browser', function () {\n\n    'use strict';\n\n    var ua = navigator.userAgent,\n        version,\n        browser = {},\n        ios = /ip(hone|od|ad)/i.test(ua),\n        android = /android/i.test(ua),\n        blackberry = /blackberry/i.test(ua),\n        webos = /webos/i.test(ua),\n        kindle = /silk|kindle/i.test(ua),\n        ie = /MSIE|Trident/i.test(ua);\n\n    if (ie) {\n        browser.ie = true;\n        if (/MSIE/i.test(ua)) {\n            version = /MSIE\\s+(\\d+\\.\\d+)/i.exec(ua);\n        } else {\n            version = /Trident.*rv[ :](\\d+\\.\\d+)/.exec(ua);\n        }\n        browser.version = version && parseFloat(version[1]);\n        browser.ielt9 = browser.version < 9;\n        browser.ielt10 = browser.version < 10;\n        browser.ielt11 = browser.version < 11;\n    }\n    if (ios) {\n        browser.ios = true;\n        version = (navigator.appVersion).match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n        browser.version = version && parseFloat(version[1] + '.' + version[2]);\n    }\n    browser.mobile = /mobile/i.test(ua) || ios || android || blackberry || webos || kindle;\n    browser.firefox = /firefox/i.test(ua);\n    if (/safari/i.test(ua)) {\n        browser.chrome = /chrome/i.test(ua);\n        browser.safari = !browser.chrome;\n    }\n    if (browser.safari) {\n        version = (navigator.appVersion).match(/Version\\/(\\d+(\\.\\d+)?)/);\n        browser.version = version && parseFloat(version[1]);\n    }\n\n    return browser;\n});\n\n/**\n * Common utility functions used throughout Crocodoc JS\n */\nCrocodoc.addUtility('common', function () {\n\n    'use strict';\n\n    var DEFAULT_PT2PX_RATIO = 1.33333;\n\n    var util = {};\n\n    util.extend = $.extend;\n    util.each = $.each;\n    util.map = $.map;\n    util.param = $.param;\n    util.parseJSON = $.parseJSON;\n    util.stringifyJSON = typeof window.JSON !== 'undefined' ?\n        window.JSON.stringify : // IE 8+\n        function () {\n            throw new Error('JSON.stringify not supported');\n        };\n\n    return $.extend(util, {\n\n        /**\n         * Left bistect of list, optionally of property of objects in list\n         * @param   {Array} list List of items to bisect\n         * @param   {number} x    The number to bisect against\n         * @param   {string} [prop] Optional property to check on list items instead of using the item itself\n         * @returns {int}      The index of the bisection\n         */\n        bisectLeft: function (list, x, prop) {\n            var val, mid, low = 0, high = list.length;\n            while (low < high) {\n                mid = Math.floor((low + high) / 2);\n                val = prop ? list[mid][prop] : list[mid];\n                if (val < x) {\n                    low = mid + 1;\n                } else {\n                    high = mid;\n                }\n            }\n            return low;\n        },\n\n        /**\n         * Right bistect of list, optionally of property of objects in list\n         * @param   {Array} list List of items to bisect\n         * @param   {number} x    The number to bisect against\n         * @param   {string} [prop] Optional property to check on list items instead of using the item itself\n         * @returns {int}      The index of the bisection\n         */\n        bisectRight: function (list, x, prop) {\n            var val, mid, low = 0, high = list.length;\n            while (low < high) {\n                mid = Math.floor((low + high) / 2);\n                val = prop ? list[mid][prop] : list[mid];\n                if (x < val) {\n                    high = mid;\n                } else {\n                    low = mid + 1;\n                }\n            }\n            return low;\n        },\n\n        /**\n         * Clamp x to range [a,b]\n         * @param   {number} x The value to clamp\n         * @param   {number} a Low value\n         * @param   {number} b High value\n         * @returns {number}   The clamped value\n         */\n        clamp: function (x, a, b) {\n            if (x < a) {\n                return a;\n            } else if (x > b) {\n                return b;\n            }\n            return x;\n        },\n\n        /**\n         * Returns the sign of the given number\n         * @param   {number} value The number\n         * @returns {number}       The sign (-1 or 1), or 0 if value === 0\n         */\n        sign: function(value) {\n            var number = parseInt(value, 10);\n            if (!number) {\n                return number;\n            }\n            return number < 0 ? -1 : 1;\n        },\n\n        /**\n         * Returns true if the given value is a function\n         * @param   {*} val Any value\n         * @returns {Boolean} true if val is a function, false otherwise\n         */\n        isFn: function (val) {\n            return typeof val === 'function';\n        },\n\n        /**\n         * Search for a specified value within an array, and return its index (or -1 if not found)\n         * @param   {*} value       The value to search for\n         * @param   {Array} array   The array to search\n         * @returns {int}           The index of value in array or -1 if not found\n         */\n        inArray: function (value, array) {\n            if (util.isFn(array.indexOf)) {\n                return array.indexOf(value);\n            } else {\n                return $.inArray(value, array);\n            }\n        },\n\n        /**\n         * Constrains the range [low,high] to the range [0,max]\n         * @param   {number} low  The low value\n         * @param   {number} high The high value\n         * @param   {number} max  The max value (0 is implicit min)\n         * @returns {Object}      The range object containing min and max values\n         */\n        constrainRange: function (low, high, max) {\n            var length = high - low;\n\n            if (length < 0) {\n                return {\n                    min: -1,\n                    max: -1\n                };\n            }\n\n            low = util.clamp(low, 0, max);\n            high = util.clamp(low + length, 0, max);\n            if (high - low < length) {\n                low = util.clamp(high - length, 0, max);\n            }\n            return {\n                min: low,\n                max: high\n            };\n        },\n\n        /**\n         * Return the current time since epoch in ms\n         * @returns {int} The current time\n         */\n        now: function () {\n            return (new Date()).getTime();\n        },\n\n        /**\n         * Creates and returns a new, throttled version of the passed function,\n         * that, when invoked repeatedly, will only actually call the original\n         * function at most once per every wait milliseconds\n         * @param   {int}      wait Time to wait between calls in ms\n         * @param   {Function} fn   The function to throttle\n         * @returns {Function}      The throttled function\n         */\n        throttle: function (wait, fn) {\n            var context,\n                args,\n                timeout,\n                result,\n                previous = 0;\n\n            function later () {\n                previous = util.now();\n                timeout = null;\n                result = fn.apply(context, args);\n            }\n\n            return function throttled() {\n                var now = util.now(),\n                    remaining = wait - (now - previous);\n                context = this;\n                args = arguments;\n                if (remaining <= 0) {\n                    clearTimeout(timeout);\n                    timeout = null;\n                    previous = now;\n                    result = fn.apply(context, args);\n                } else if (!timeout) {\n                    timeout = setTimeout(later, remaining);\n                }\n                return result;\n            };\n        },\n\n        /**\n         * Creates and returns a new debounced version of the passed function\n         * which will postpone its execution until after wait milliseconds\n         * have elapsed since the last time it was invoked.\n         * @param   {int}      wait Time to wait between calls in ms\n         * @param   {Function} fn   The function to debounced\n         * @returns {Function}      The debounced function\n         */\n        debounce: function (wait, fn) {\n            var context,\n                args,\n                timeout,\n                timestamp,\n                result;\n\n            function later() {\n                var last = util.now() - timestamp;\n                if (last < wait) {\n                    timeout = setTimeout(later, wait - last);\n                } else {\n                    timeout = null;\n                    result = fn.apply(context, args);\n                    context = args = null;\n                }\n            }\n\n            return function debounced() {\n                context = this;\n                args = arguments;\n                timestamp = util.now();\n                if (!timeout) {\n                    timeout = setTimeout(later, wait);\n                }\n                return result;\n            };\n        },\n\n        /**\n         * Insert the given CSS string into the DOM and return the resulting DOMElement\n         * @param   {string} css The CSS string to insert\n         * @returns {Element}    The <style> element that was created and inserted\n         */\n        insertCSS: function (css) {\n            var styleEl = document.createElement('style'),\n                cssTextNode = document.createTextNode(css);\n            try {\n                styleEl.setAttribute('type', 'text/css');\n                styleEl.appendChild(cssTextNode);\n            } catch (err) {\n                // uhhh IE < 9\n            }\n            document.getElementsByTagName('head')[0].appendChild(styleEl);\n            return styleEl;\n        },\n\n        /**\n         * Append a CSS rule to the given stylesheet\n         * @param   {CSSStyleSheet} sheet The stylesheet object\n         * @param   {string} selector     The selector\n         * @param   {string} rule         The rule\n         * @returns {int}                 The index of the new rule\n         */\n        appendCSSRule: function (sheet, selector, rule) {\n            var index;\n            if (sheet.insertRule) {\n                return sheet.insertRule(selector + '{' + rule + '}', sheet.cssRules.length);\n            } else {\n                index = sheet.addRule(selector, rule, sheet.rules.length);\n                if (index < 0) {\n                    index = sheet.rules.length - 1;\n                }\n                return index;\n            }\n        },\n\n        /**\n         * Delete a CSS rule at the given index from the given stylesheet\n         * @param   {CSSStyleSheet} sheet The stylesheet object\n         * @param   {int} index           The index of the rule to delete\n         * @returns {void}\n         */\n        deleteCSSRule: function (sheet, index) {\n            if (sheet.deleteRule) {\n                sheet.deleteRule(index);\n            } else {\n                sheet.removeRule(index);\n            }\n        },\n\n        /**\n         * Get the parent element of the (first) text node that is currently selected\n         * @returns {Element} The selected element\n         * @TODO: return all selected elements\n         */\n        getSelectedNode: function () {\n            var node, sel, range;\n            if (window.getSelection) {\n                sel = window.getSelection();\n                if (sel.rangeCount) {\n                    range = sel.getRangeAt(0);\n                    if (!range.collapsed) {\n                        node = sel.anchorNode.parentNode;\n                    }\n                }\n            } else if (document.selection) {\n                node = document.selection.createRange().parentElement();\n            }\n            return node;\n        },\n\n        /**\n         * Cross-browser getComputedStyle, which is faster than jQuery.css\n         * @param   {HTMLElement} el      The element\n         * @returns {CSSStyleDeclaration} The computed styles\n         */\n        getComputedStyle: function (el) {\n            if ('getComputedStyle' in window) {\n                return window.getComputedStyle(el);\n            }\n            // IE <= 8\n            return el.currentStyle;\n        },\n\n        /**\n         * Calculates the size of 1pt in pixels\n         * @returns {number} The pixel value\n         */\n        calculatePtSize: function () {\n            var style,\n                px,\n                testSize = 10000,\n                div = document.createElement('div');\n            div.style.display = 'block';\n            div.style.position = 'absolute';\n            div.style.width = testSize + 'pt';\n            document.body.appendChild(div);\n            style = util.getComputedStyle(div);\n            if (style && style.width) {\n                px = parseFloat(style.width) / testSize;\n            } else {\n                // @NOTE: there is a bug in Firefox where `getComputedStyle()`\n                // returns null if called in a hidden (`display:none`) iframe\n                // (https://bugzilla.mozilla.org/show_bug.cgi?id=548397), so we\n                // fallback to a default value if this happens.\n                px = DEFAULT_PT2PX_RATIO;\n            }\n            document.body.removeChild(div);\n            return px;\n        },\n\n        /**\n         * Count and return the number of occurrences of token in str\n         * @param   {string} str   The string to search\n         * @param   {string} token The string to search for\n         * @returns {int}          The number of occurrences\n         */\n        countInStr: function (str, token) {\n            var total = 0, i;\n            while ((i = str.indexOf(token, i) + 1)) {\n                total++;\n            }\n            return total;\n        },\n\n        /**\n         * Apply the given data to a template\n         * @param   {string} template  The template\n         * @param   {Object} data The data to apply to the template\n         * @returns {string}      The filled template\n         */\n        template: function (template, data) {\n            var p;\n            for (p in data) {\n                if (data.hasOwnProperty(p)) {\n                    template = template.replace(new RegExp('\\\\{\\\\{' + p + '\\\\}\\\\}', 'g'), data[p]);\n                }\n            }\n            return template;\n        }\n    });\n});\n\n/*global window, document*/\nCrocodoc.addUtility('subpx', function (framework) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var CSS_CLASS_SUBPX_FIX = 'crocodoc-subpx-fix',\n        TEST_SPAN_TEMPLATE = '<span style=\"font:{{size}}px serif; color:transparent; white-space:nowrap;\">' +\n            (new Array(100)).join('A') + '</span>'; // repeat 'A' character;\n\n    var util = framework.getUtility('common');\n\n    /**\n     * Return true if subpixel rendering is supported\n     * @returns {Boolean}\n     * @private\n     */\n    function isSubpixelRenderingSupported() {\n        // Test if subpixel rendering is supported\n        // @NOTE: jQuery.support.leadingWhitespace is apparently false if browser is IE6-8\n        if (!$.support.leadingWhitespace) {\n            return false;\n        } else {\n            //span #1 - desired font-size: 12.5px\n            var span = $(util.template(TEST_SPAN_TEMPLATE, { size: 12.5 }))\n                .appendTo(document.documentElement).get(0);\n            var fontsize1 = $(span).css('font-size');\n            var width1 = $(span).width();\n            $(span).remove();\n\n            //span #2 - desired font-size: 12.6px\n            span = $(util.template(TEST_SPAN_TEMPLATE, { size: 12.6 }))\n                .appendTo(document.documentElement).get(0);\n            var fontsize2 = $(span).css('font-size');\n            var width2 = $(span).width();\n            $(span).remove();\n\n            // is not mobile device?\n            // @NOTE(plai): Mobile WebKit supports subpixel rendering even though the browser fails the following tests.\n            // @NOTE(plai): When modifying these tests, make sure that these tests will work even when the browser zoom is changed.\n            // @TODO(plai): Find a better way of testing for mobile Safari.\n            if (!('ontouchstart' in window)) {\n\n                //font sizes are the same? (Chrome and Safari will fail this)\n                if (fontsize1 === fontsize2) {\n                    return false;\n                }\n\n                //widths are the same? (Firefox on Windows without GPU will fail this)\n                if (width1 === width2) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    var subpixelRenderingIsSupported = isSubpixelRenderingSupported();\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Apply the subpixel rendering fix to the given element if necessary.\n         * @NOTE: Fix is only applied if the \"zoom\" CSS property exists\n         *        (ie., this fix is never applied in Firefox)\n         * @param   {Element} el The element\n         * @returns {Element} The element\n         */\n        fix: function (el) {\n            if (!subpixelRenderingIsSupported) {\n                if (document.body.style.zoom !== undefined) {\n                    var $wrap = $('<div>').addClass(CSS_CLASS_SUBPX_FIX);\n                    $(el).wrap($wrap);\n                }\n            }\n            return el;\n        },\n\n        /**\n         * Is sub-pixel text rendering supported?\n         * @param   {void}\n         * @returns {boolean} true if sub-pixel tex rendering is supported\n         */\n        isSubpxSupported: function() {\n            return subpixelRenderingIsSupported;\n        }\n    };\n});\n\nCrocodoc.addUtility('support', function () {\n\n    'use strict';\n    var prefixes = ['Moz', 'Webkit', 'O', 'ms'],\n        xhrSupported = null,\n        xhrCORSSupported = null;\n\n    /**\n     * Helper function to get the proper vendor property name\n     * (`transition` => `WebkitTransition`)\n     * @param {string} prop The property name to test for\n     * @returns {string|boolean} The vendor-prefixed property name or false if the property is not supported\n     */\n    function getVendorCSSPropertyName(prop) {\n        var testDiv = document.createElement('div'),\n            prop_, i, vendorProp;\n\n        // Handle unprefixed versions (FF16+, for example)\n        if (prop in testDiv.style) {\n            return prop;\n        }\n\n        prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);\n\n        if (prop in testDiv.style) {\n            return prop;\n        }\n\n        for (i = 0; i < prefixes.length; ++i) {\n            vendorProp = prefixes[i] + prop_;\n            if (vendorProp in testDiv.style) {\n                if (vendorProp.indexOf('ms') === 0) {\n                    vendorProp = '-' + vendorProp;\n                }\n                return uncamel(vendorProp);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Converts a camelcase string to a dasherized string.\n     * (`marginLeft` => `margin-left`)\n     * @param {stirng} str The camelcase string to convert\n     * @returns {string} The dasherized string\n     */\n    function uncamel(str) {\n        return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });\n    }\n\n    return {\n        svg: document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1'),\n        csstransform: getVendorCSSPropertyName('transform'),\n        csstransition: getVendorCSSPropertyName('transition'),\n        csszoom: getVendorCSSPropertyName('zoom'),\n\n        /**\n         * Return true if XHR is supported\n         * @returns {boolean}\n         */\n        isXHRSupported: function () {\n            if (xhrSupported === null) {\n                xhrSupported = !!this.getXHR();\n            }\n            return xhrSupported;\n        },\n\n        /**\n         * Return true if XHR is supported and is CORS-enabled\n         * @returns {boolean}\n         */\n        isCORSSupported: function () {\n            if (xhrCORSSupported === null) {\n                xhrCORSSupported = this.isXHRSupported() &&\n                                   ('withCredentials' in this.getXHR());\n            }\n            return xhrCORSSupported;\n        },\n\n        /**\n         * Return true if XDR is supported\n         * @returns {boolean}\n         */\n        isXDRSupported: function () {\n            return typeof window.XDomainRequest !== 'undefined';\n        },\n\n        /**\n         * Get a XHR object\n         * @returns {XMLHttpRequest} An XHR object\n         */\n        getXHR: function () {\n            if (window.XMLHttpRequest) {\n                return new window.XMLHttpRequest();\n            } else {\n                try {\n                    return new ActiveXObject('MSXML2.XMLHTTP.3.0');\n                }\n                catch(ex) {\n                    return null;\n                }\n            }\n        },\n\n        /**\n         * Get a CORS-enabled request object\n         * @returns {XMLHttpRequest|XDomainRequest} The request object\n         */\n        getXDR: function () {\n            if (this.isXDRSupported()) {\n                return new window.XDomainRequest();\n            }\n            return null;\n        }\n    };\n});\n\n/**\n * URL utility\n */\nCrocodoc.addUtility('url', function (framework) {\n\n    'use strict';\n\n    var browser = framework.getUtility('browser'),\n        parsedLocation;\n\n    return {\n        /**\n         * Return the current page's URL\n         * @returns {string} The current URL\n         */\n        getCurrentURL: function () {\n            return window.location.href;\n        },\n\n        /**\n         * Make the given path absolute\n         *  - if path doesn't contain protocol and domain, prepend the current protocol and domain\n         *  - if the path is relative (eg. doesn't begin with /), also fill in the current path\n         * @param   {string} path The path to make absolute\n         * @returns {string}      The absolute path\n         */\n        makeAbsolute: function (path) {\n            return this.parse(path).href;\n        },\n\n        /**\n         * Returns true if the given url is external to the current domain\n         * @param   {string}  url The URL\n         * @returns {Boolean} Whether or not the url is external\n         */\n        isCrossDomain: function (url) {\n            var parsedURL = this.parse(url);\n\n            if (!parsedLocation) {\n                parsedLocation = this.parse(this.getCurrentURL());\n            }\n\n            // IE7 does not properly parse relative URLs, so the hostname is empty\n            if (!parsedURL.hostname) {\n                return false;\n            }\n\n            return parsedURL.protocol !== parsedLocation.protocol ||\n                   parsedURL.hostname !== parsedLocation.hostname ||\n                   parsedURL.port !== parsedLocation.port;\n        },\n\n        /**\n         * Append a query parameters string to the given URL\n         * @param   {string} url The URL\n         * @param   {string} str The query parameters\n         * @returns {string}     The new URL\n         */\n        appendQueryParams: function (url, str) {\n            if (url.indexOf('?') > -1) {\n                return url + '&' + str;\n            } else {\n                return url + '?' + str;\n            }\n        },\n\n        /**\n         * Parse a URL into protocol, host, port, etc\n         * @param   {string} url The URL to parse\n         * @returns {object}     The parsed URL parts\n         */\n        parse: function (url) {\n            var parsed = document.createElement('a'),\n                pathname;\n\n            parsed.href = url;\n\n            // @NOTE: IE does not automatically parse relative urls,\n            // but requesting href back from the <a> element will return\n            // an absolute URL, which can then be fed back in to get the\n            // expected result. WTF? Yep!\n            if (browser.ie && url !== parsed.href) {\n                url = parsed.href;\n                parsed.href = url;\n            }\n\n            // @NOTE: IE does not include the preceding '/' in pathname\n            pathname = parsed.pathname;\n            if (!/^\\//.test(pathname)) {\n                pathname = '/' + pathname;\n            }\n\n            return {\n                href: parsed.href,\n                protocol: parsed.protocol, // includes :\n                host: parsed.host, // includes port\n                hostname: parsed.hostname, // does not include port\n                port: parsed.port,\n                pathname: pathname,\n                hash: parsed.hash,  // inclues #\n                search: parsed.search // incudes ?\n            };\n        }\n    };\n});\n\nCrocodoc.addComponent('controller-paged', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var util = scope.getUtility('common');\n\n    var config,\n        $el,\n        lazyLoader;\n\n    /**\n     * Validates the config options\n     * @returns {void}\n     * @private\n     */\n    function validateConfig() {\n        var metadata = config.metadata;\n        config.numPages = metadata.numpages;\n        if (!config.pageStart) {\n            config.pageStart = 1;\n        } else if (config.pageStart < 0) {\n            config.pageStart = metadata.numpages + config.pageStart;\n        }\n        config.pageStart = util.clamp(config.pageStart, 1, metadata.numpages);\n        if (!config.pageEnd) {\n            config.pageEnd = metadata.numpages;\n        } else if (config.pageEnd < 0) {\n            config.pageEnd = metadata.numpages + config.pageEnd;\n        }\n        config.pageEnd = util.clamp(config.pageEnd, config.pageStart, metadata.numpages);\n        config.numPages = config.pageEnd - config.pageStart + 1;\n    }\n\n    /**\n     * Create the html skeleton for the viewer and pages\n     * @returns {void}\n     * @private\n     */\n    function prepareDOM() {\n        var i, pageNum,\n            zoomLevel, maxZoom,\n            ptWidth, ptHeight,\n            pxWidth, pxHeight,\n            pt2px = util.calculatePtSize(),\n            dimensions = config.metadata.dimensions,\n            skeleton = '';\n\n        // adjust page scale if the pages are too small/big\n        // it's adjusted so 100% == DOCUMENT_100_PERCENT_WIDTH px;\n        config.pageScale = DOCUMENT_100_PERCENT_WIDTH / (dimensions.width * pt2px);\n\n        // add zoom levels to accomodate the scale\n        zoomLevel = config.zoomLevels[config.zoomLevels.length - 1];\n        maxZoom = 3 / config.pageScale;\n        while (zoomLevel < maxZoom) {\n            zoomLevel += zoomLevel / 2;\n            config.zoomLevels.push(zoomLevel);\n        }\n\n        dimensions.exceptions = dimensions.exceptions || {};\n\n        // create skeleton\n        for (i = config.pageStart - 1; i < config.pageEnd; i++) {\n            pageNum = i + 1;\n            if (pageNum in dimensions.exceptions) {\n                ptWidth = dimensions.exceptions[pageNum].width;\n                ptHeight = dimensions.exceptions[pageNum].height;\n            } else {\n                ptWidth = dimensions.width;\n                ptHeight = dimensions.height;\n            }\n            pxWidth = ptWidth * pt2px;\n            pxHeight = ptHeight * pt2px;\n            pxWidth *= config.pageScale;\n            pxHeight *= config.pageScale;\n            skeleton += util.template(Crocodoc.pageTemplate, {\n                w: pxWidth,\n                h: pxHeight\n            });\n        }\n\n        // insert skeleton and keep a reference to the jq object\n        config.$pages = $(skeleton).appendTo(config.$doc);\n    }\n\n    /**\n     * Return the expected conversion status of the given page index\n     * @param   {int} pageIndex The page index\n     * @returns {string}        The page status\n     */\n    function getInitialPageStatus(pageIndex) {\n        if (config.conversionIsComplete ||\n            (pageIndex === 0 && config.autoloadFirstPage)) {\n            return PAGE_STATUS_NOT_LOADED;\n        }\n        return PAGE_STATUS_CONVERTING;\n    }\n\n    /**\n     * Create and init all necessary page component instances\n     * @returns {void}\n     * @private\n     */\n    function createPages() {\n        var i,\n            pages = [],\n            page,\n            start = config.pageStart - 1,\n            end = config.pageEnd,\n            links = sortPageLinks();\n\n        //initialize pages\n        for (i = start; i < end; i++) {\n            page = scope.createComponent('page');\n            page.init(config.$pages.eq(i - start), {\n                index: i,\n                status: getInitialPageStatus(i),\n                enableLinks: config.enableLinks,\n                links: links[i],\n                pageScale: config.pageScale\n            });\n            pages.push(page);\n        }\n        config.pages = pages;\n    }\n\n    /**\n     * Returns all links associated with the given page\n     * @param  {int} page The page\n     * @returns {Array}   Array of links\n     * @private\n     */\n    function sortPageLinks() {\n        var i, len, link,\n            destination,\n            // the starting and ending page *numbers* (not indexes)\n            start = config.pageStart,\n            end = config.pageEnd,\n            links = config.metadata.links || [],\n            sorted = [];\n\n        // NOTE:\n        // link.pagenum is the page the link resides on\n        // link.destination.pagenum is the page the link links to\n\n        for (i = 0, len = config.metadata.numpages; i < len; ++i) {\n            sorted[i] = [];\n        }\n\n        for (i = 0, len = links.length; i < len; ++i) {\n            link = links[i];\n\n            if (link.pagenum < start || link.pagenum > end) {\n                // link page is outside the enabled page range\n                continue;\n            }\n\n            if (link.destination) {\n                destination = link.destination.pagenum;\n\n                if (destination < start || destination > end) {\n                    // destination is outside the enabled page range\n                    continue;\n                } else {\n                    // subtract the number of pages cut off from the beginning\n                    link.destination.pagenum = destination - (start - 1);\n                }\n            }\n\n            sorted[link.pagenum - 1].push(link);\n        }\n\n        return sorted;\n    }\n\n    /**\n     * Handle mouseup events\n     * @returns {void}\n     * @private\n     */\n    function handleMouseUp() {\n        updateSelectedPages();\n    }\n\n    /**\n     * Check if text is selected on any page, and if so, add a css class to that page\n     * @returns {void}\n     * @TODO(clakenen): this method currently only adds the selected class to one page,\n     * so we should modify it to add the class to all pages with selected text\n     * @private\n     */\n    function updateSelectedPages() {\n        var node = util.getSelectedNode();\n        var $page = $(node).closest('.'+CSS_CLASS_PAGE);\n        $el.find('.'+CSS_CLASS_TEXT_SELECTED).removeClass(CSS_CLASS_TEXT_SELECTED);\n        if (node && $el.has(node)) {\n            $page.addClass(CSS_CLASS_TEXT_SELECTED);\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n\n        /**\n         * Initialize the controller\n         * @returns {void}\n         */\n        init: function () {\n            config = scope.getConfig();\n\n            // Setup container\n            $el = config.$el;\n\n            $(document).on('mouseup', handleMouseUp);\n\n            validateConfig();\n            prepareDOM();\n            createPages();\n\n            lazyLoader = scope.createComponent('lazy-loader');\n            lazyLoader.init(config.pages);\n        },\n\n        /**\n         * Destroy the viewer-base component\n         * @returns {void}\n         */\n        destroy: function () {\n            // remove document event handlers\n            $(document).off('mouseup', handleMouseUp);\n        }\n    };\n});\n\nCrocodoc.addComponent('controller-text', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var $promise;\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n\n        /**\n         * Initialize the controller\n         * @returns {void}\n         */\n        init: function () {\n            var config = scope.getConfig();\n            config.$textContainer = $();\n\n            // we can just load the text immediately\n            $promise = scope.get('page-text', 1).then(function (html) {\n                // the viewport could be window in useWindowAsViewport, so get\n                // the real viewport div\n                var $viewport = config.$doc.parent();\n                config.$doc = $(html);\n                $viewport.html(config.$doc);\n            });\n        },\n\n        /**\n         * Destroy the viewer-base component\n         * @returns {void}\n         */\n        destroy: function () {\n            $promise.abort();\n        }\n    };\n});\n\n/**\n * Dragger component definition\n */\nCrocodoc.addComponent('dragger', function (scope) {\n\n    'use strict';\n\n    var $el,\n        $window = $(window),\n        downScrollPosition,\n        downMousePosition;\n\n    /**\n     * Handle mousemove events\n     * @param   {Event} event The event object\n     * @returns {void}\n     */\n    function handleMousemove(event) {\n        $el.scrollTop(downScrollPosition.top - (event.clientY - downMousePosition.y));\n        $el.scrollLeft(downScrollPosition.left - (event.clientX - downMousePosition.x));\n        event.preventDefault();\n    }\n\n    /**\n     * Handle mouseup events\n     * @param   {Event} event The event object\n     * @returns {void}\n     */\n    function handleMouseup(event) {\n        scope.broadcast('dragend');\n        $window.off('mousemove', handleMousemove);\n        $window.off('mouseup', handleMouseup);\n        event.preventDefault();\n    }\n\n    /**\n     * Handle mousedown events\n     * @param   {Event} event The event object\n     * @returns {void}\n     */\n    function handleMousedown(event) {\n        scope.broadcast('dragstart');\n        downScrollPosition = {\n            top: $el.scrollTop(),\n            left: $el.scrollLeft()\n        };\n        downMousePosition = {\n            x: event.clientX,\n            y: event.clientY\n        };\n        $window.on('mousemove', handleMousemove);\n        $window.on('mouseup', handleMouseup);\n        event.preventDefault();\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Initialize the scroller component\n         * @param   {Element} el The Element\n         * @returns {void}\n         */\n        init: function (el) {\n            $el = $(el);\n            $el.on('mousedown', handleMousedown);\n        },\n\n        /**\n         * Destroy the scroller component\n         * @returns {void}\n         */\n        destroy: function () {\n            $el.off('mousedown', handleMousedown);\n            $el.off('mousemove', handleMousemove);\n            $window.off('mouseup', handleMouseup);\n        }\n    };\n});\n\n/**\n * Base layout component for controlling viewer layout and viewport\n */\nCrocodoc.addComponent('layout-base', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var util = scope.getUtility('common');\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        messages: [\n            'resize',\n            'scroll',\n            'scrollend'\n        ],\n\n        /**\n         * Handle framework messages\n         * @param {string} name The name of the message\n         * @param {Object} data The related data for the message\n         * @returns {void}\n         */\n        onmessage: function (name, data) {\n            switch (name) {\n                case 'resize':\n                    this.handleResize(data);\n                    break;\n                case 'scroll':\n                    this.handleScroll(data);\n                    break;\n                case 'scrollend':\n                    this.handleScrollEnd(data);\n                    break;\n                // no default\n            }\n        },\n\n        /**\n         * Initialize the Layout component\n         * @returns {void}\n         */\n        init: function () {\n            var config = scope.getConfig();\n            this.config = config;\n            // shortcut references to jq DOM objects\n            this.$el = config.$el;\n            this.$doc = config.$doc;\n            this.$viewport = config.$viewport;\n            this.$pages = config.$pages;\n            this.numPages = config.numPages;\n\n            // add the layout css class\n            this.layoutClass = CSS_CLASS_LAYOUT_PREFIX + config.layout;\n            this.$el.addClass(this.layoutClass);\n\n            this.initState();\n        },\n\n        /**\n         * Initalize the state object\n         * @returns {void}\n         */\n        initState: function () {\n            var viewportEl = this.$viewport[0],\n                dimensionsEl = viewportEl;\n\n            // use the documentElement for viewport dimensions\n            // if we are using the window as the viewport\n            if (viewportEl === window) {\n                dimensionsEl = document.documentElement;\n            }\n            // setup initial state\n            this.state = {\n                scrollTop: viewportEl.scrollTop,\n                scrollLeft: viewportEl.scrollLeft,\n                viewportDimensions: {\n                    clientWidth: dimensionsEl.clientWidth,\n                    clientHeight: dimensionsEl.clientHeight,\n                    offsetWidth: dimensionsEl.offsetWidth,\n                    offsetHeight: dimensionsEl.offsetHeight\n                },\n                zoomState: {\n                    zoom: 1,\n                    prevZoom: 0,\n                    zoomMode: null\n                },\n                initialWidth: 0,\n                initialHeight: 0,\n                totalWidth: 0,\n                totalHeight: 0\n            };\n            this.zoomLevels = [];\n        },\n\n        /**\n         * Destroy the Layout component\n         * @returns {void}\n         */\n        destroy: function () {\n            this.$doc.removeAttr('style');\n            this.$el.removeClass(this.layoutClass);\n        },\n\n        /**\n         * Set the zoom level for the layout (to be implemented)\n         */\n        setZoom: function () {},\n\n        /**\n         * Calculate the next zoom level for zooming in or out\n         * @param   {string} direction Can be either Crocodoc.ZOOM_IN or Crocodoc.ZOOM_OUT\n         * @returns {number|boolean} The next zoom level or false if the viewer cannot be\n         *                               zoomed in the given direction\n         */\n        calculateNextZoomLevel: function (direction) {\n            var i,\n                zoom = false,\n                currentZoom = this.state.zoomState.zoom,\n                zoomLevels = this.zoomLevels;\n\n            if (direction === Crocodoc.ZOOM_IN) {\n                for (i = 0; i < zoomLevels.length; ++i) {\n                    if (zoomLevels[i] > currentZoom) {\n                        zoom = zoomLevels[i];\n                        break;\n                    }\n                }\n            } else if (direction === Crocodoc.ZOOM_OUT) {\n                for (i = zoomLevels.length - 1; i >= 0; --i) {\n                    if (zoomLevels[i] < currentZoom) {\n                        zoom = zoomLevels[i];\n                        break;\n                    }\n                }\n            }\n\n            return zoom;\n        },\n\n        /**\n         * Returns true if the layout is currently draggable\n         * (in this case that means that the viewport is scrollable)\n         * @returns {Boolean} Whether this layout is draggable\n         */\n        isDraggable: function () {\n            var state = this.state;\n            return (state.viewportDimensions.clientHeight < state.totalHeight) ||\n                   (state.viewportDimensions.clientWidth < state.totalWidth);\n        },\n\n        /**\n         * Scrolls by the given pixel amount from the current location\n         * @param  {int} left Left offset to scroll to\n         * @param  {int} top  Top offset to scroll to\n         * @returns {void}\n         */\n        scrollBy: function (left, top) {\n            left = parseInt(left, 10) || 0;\n            top = parseInt(top, 10) || 0;\n            this.scrollToOffset(left + this.state.scrollLeft, top + this.state.scrollTop);\n        },\n\n        /**\n         * Scroll to the given left and top offset\n         * @param   {int} left The left offset\n         * @param   {int} top  The top offset\n         * @returns {void}\n         */\n        scrollToOffset: function (left, top) {\n            this.$viewport.scrollLeft(left);\n            this.$viewport.scrollTop(top);\n        },\n\n        /**\n         * Handle scroll messages\n         * @param   {Object} data Object containing scrollTop and scrollLeft of the viewport\n         * @returns {void}\n         */\n        handleScroll: function (data) {\n            this.state.scrollTop = data.scrollTop;\n            this.state.scrollLeft = data.scrollLeft;\n        },\n\n        /**\n         * Handle resize messages (to be implemented in layout)\n         */\n        handleResize: function () {},\n        /**\n         * Handle scrollend messages (to be implemented in layout)\n         */\n        handleScrollEnd: function () {},\n\n        /**\n         * Force a full layout update (to be implemented in layout)\n         */\n        update: function () {},\n\n        /**\n         * Focuses the viewport so it can be natively scrolled with the keyboard\n         * @returns {void}\n         */\n        focus: function () {\n            this.$viewport.focus();\n        },\n\n        /**\n         * Shortcut method to extend this layout\n         * @param   {Object} layout The layout mixins\n         * @returns {Object}        The extended layout\n         */\n        extend: function (layout) {\n            return util.extend({}, this, layout);\n        }\n    };\n});\n\n/**\n * The horizontal layout\n */\nCrocodoc.addComponent('layout-' + LAYOUT_HORIZONTAL, ['layout-paged'], function (scope, paged) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var util = scope.getUtility('common'),\n        browser = scope.getUtility('browser');\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return paged.extend({\n\n        /**\n         * Calculate the numeric value for zoom 'auto' for this layout mode\n         * @returns {float} The zoom value\n         */\n        calculateZoomAutoValue: function () {\n            var state = this.state,\n                fitWidth = this.calculateZoomValue(ZOOM_FIT_WIDTH),\n                fitHeight = this.calculateZoomValue(ZOOM_FIT_HEIGHT);\n\n            // landscape\n            if (state.widestPage.actualWidth > state.tallestPage.actualHeight) {\n                return Math.min(fitWidth, fitHeight);\n            }\n            // portrait\n            else {\n                if (browser.mobile) {\n                    return fitHeight;\n                }\n                // limit max zoom to 1.0\n                return Math.min(1, fitHeight);\n            }\n        },\n\n        /**\n         * Calculate which page is currently the \"focused\" page.\n         * In horizontal mode, this is the page farthest to the left,\n         * where at least half of the page is showing.\n         * @returns {int} The current page\n         */\n        calculateCurrentPage: function () {\n            var prev, page,\n                state = this.state,\n                pages = state.pages;\n\n            prev = util.bisectRight(pages, state.scrollLeft, 'x0') - 1;\n            page = util.bisectRight(pages, state.scrollLeft + pages[prev].width / 2, 'x0') - 1;\n            return 1 + page;\n        },\n\n        /**\n         * Calculates the next page\n         * @returns {int} The next page number\n         */\n        calculateNextPage: function () {\n            return this.state.currentPage + 1;\n        },\n\n        /**\n         * Calculates the previous page\n         * @returns {int} The previous page number\n         */\n        calculatePreviousPage: function () {\n            return this.state.currentPage - 1;\n        },\n\n        /**\n         * Handle resize mesages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handleResize: function (data) {\n            paged.handleResize.call(this, data);\n            this.updateCurrentPage();\n        },\n\n        /**\n         * Handle scroll mesages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handleScroll: function (data) {\n            paged.handleScroll.call(this, data);\n            this.updateCurrentPage();\n        },\n\n        /**\n         * Updates the layout elements (pages, doc, etc) CSS\n         * appropriately for the current zoom level\n         * @returns {void}\n         */\n        updateLayout: function () {\n            var state = this.state,\n                zoomState = state.zoomState,\n                zoom = zoomState.zoom,\n                zoomedWidth = state.sumWidths,\n                zoomedHeight = Math.floor(state.tallestPage.totalActualHeight * zoom),\n                docWidth = Math.max(zoomedWidth, state.viewportDimensions.clientWidth),\n                docHeight = Math.max(zoomedHeight, state.viewportDimensions.clientHeight);\n\n            this.$doc.css({\n                height: docHeight,\n                lineHeight: docHeight + 'px',\n                width: docWidth\n            });\n        }\n    });\n});\n\n\n/**\n * Base layout component for controlling viewer layout and viewport\n */\nCrocodoc.addComponent('layout-paged', ['layout-base'], function (scope, base) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var util = scope.getUtility('common'),\n        support = scope.getUtility('support');\n\n    /**\n     * Apply a zoom transform to the layout using width/height\n     * (using width/height instead)\n     * @param   {float} zoom The zoom value\n     * @returns {void}\n     * @private\n     */\n    function applyZoomResize(layout, zoom) {\n        // manually resize pages width/height\n        var i, len, pageState, cssRule,\n            state = layout.state,\n            selector = '.' + layout.config.namespace + ' .' + CSS_CLASS_PAGE_AUTOSCALE,\n            stylesheet = layout.config.stylesheet,\n            pages = state.pages,\n            scale = zoom * layout.config.pageScale,\n            percent = 100 / scale;\n\n        // apply css transform or zoom to autoscale layer (eg., text, links, user content)\n        if (support.csstransform) {\n            cssRule = support.csstransform + ':scale(' + scale + ');' +\n                'width:' + percent + '%;' +\n                'height:' + percent + '%;';\n        } else if (support.csszoom) {\n            cssRule = 'zoom:' + scale;\n        } else {\n            // should not happen...\n            cssRule = '';\n        }\n\n        // remove the previous style if there is one\n        if (state.previousStyleIndex) {\n            util.deleteCSSRule(stylesheet, state.previousStyleIndex);\n        }\n        // create a new rule for the autoscale layer\n        state.previousStyleIndex = util.appendCSSRule(stylesheet, selector, cssRule);\n\n        // update width/height/padding on all pages\n        for (i = 0, len = pages.length; i < len; ++i) {\n            pageState = pages[i];\n            layout.$pages.eq(i).css({\n                width: pageState.actualWidth * zoom,\n                height: pageState.actualHeight * zoom,\n                paddingTop: pageState.paddingTop * zoom,\n                paddingRight: pageState.paddingRight * zoom,\n                paddingBottom: pageState.paddingBottom * zoom,\n                paddingLeft: pageState.paddingLeft * zoom\n            });\n        }\n    }\n\n    /**\n     * Get the maximum y1 value for pages in the current row\n     * (or Infinity if there are no pages in the current row yet)\n     * @param {Array} pages Array of pages to search\n     * @param {Array} row   Array of page indexes (i.e., the row)\n     * @returns {number} The max y1 value\n     * @private\n     */\n    function getMaxY1InRow(pages, row) {\n        if (!row || row.length === 0) {\n            return Infinity;\n        }\n        var y1s = util.map(row, function (pageIndex) {\n            return pages[pageIndex].y1;\n        });\n        return Math.max.apply(Math, y1s);\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return base.extend({\n\n        /**\n         * Initialize the Layout component\n         * @returns {void}\n         */\n        init: function () {\n            base.init.call(this);\n            this.updatePageStates();\n            this.updateZoomLevels();\n        },\n\n        /**\n         * Initalize the state object\n         * @returns {void}\n         */\n        initState: function () {\n            base.initState.call(this);\n            util.extend(this.state, {\n                pages: [],\n                widestPage: {\n                    index: 0,\n                    actualWidth: 0\n                },\n                tallestPage: {\n                    index: 0,\n                    actualHeight: 0\n                },\n                sumWidths: 0,\n                sumHeights: 0,\n                rows: [],\n                currentPage: null,\n                visiblePages: [],\n                fullyVisiblePages: []\n            });\n        },\n\n        /**\n         * Destroy the Layout component\n         * @returns {void}\n         */\n        destroy: function () {\n            base.destroy.call(this);\n            this.$pages.css('padding', '');\n        },\n\n        /**\n         * Force a full layout update\n         */\n        update: function () {\n            this.updatePageStates(true);\n            this.setZoom();\n        },\n\n        /**\n         * Set the zoom level for the layout\n         * @param {float|string} val The zoom level (float or one of the zoom constants)\n         */\n        setZoom: function (val) {\n            var state = this.state,\n                zoom = this.parseZoomValue(val),\n                zoomState = state.zoomState,\n                currentZoom = zoomState.zoom,\n                zoomMode,\n                shouldNotCenter;\n\n            // update the zoom mode if we landed on a named mode\n            zoomMode = this.calculateZoomMode(val, zoom);\n\n            //respect zoom constraints\n            zoom = util.clamp(zoom, state.minZoom, state.maxZoom);\n\n            scope.broadcast('beforezoom', util.extend({\n                page: state.currentPage,\n                visiblePages: util.extend([], state.visiblePages),\n                fullyVisiblePages: util.extend([], state.fullyVisiblePages)\n            }, zoomState));\n\n            // update the zoom state\n            zoomState.prevZoom = currentZoom;\n            zoomState.zoom = zoom;\n            zoomState.zoomMode = zoomMode;\n\n            // apply the zoom to the actual DOM element(s)\n            this.applyZoom(zoom);\n\n            // can the document be zoomed in/out further?\n            zoomState.canZoomIn = this.calculateNextZoomLevel(Crocodoc.ZOOM_IN) !== false;\n            zoomState.canZoomOut = this.calculateNextZoomLevel(Crocodoc.ZOOM_OUT) !== false;\n\n            // update page states, because they will have changed after zooming\n            this.updatePageStates();\n\n            // layout mode specific stuff\n            this.updateLayout();\n\n            // update scroll position for the new zoom\n            // @NOTE: updateScrollPosition() must be called AFTER updateLayout(),\n            // because the scrollable space may change in updateLayout\n            // @NOTE: shouldNotCenter is true when using a named zoom level\n            // so that resizing the browser zooms to the current page offset\n            // rather than to the center like when zooming in/out\n            shouldNotCenter = val === Crocodoc.ZOOM_AUTO ||\n                              val === Crocodoc.ZOOM_FIT_WIDTH ||\n                              val === Crocodoc.ZOOM_FIT_HEIGHT;\n            this.updateScrollPosition(shouldNotCenter);\n\n            // update again, because updateLayout could have changed page positions\n            this.updatePageStates();\n\n            // make sure the visible pages are accurate (also update css classes)\n            this.updateVisiblePages(true);\n\n            // broadcast zoom event with new zoom state\n            scope.broadcast('zoom', util.extend({\n                page: state.currentPage,\n                visiblePages: util.extend([], state.visiblePages),\n                fullyVisiblePages: util.extend([], state.fullyVisiblePages),\n                isDraggable: this.isDraggable()\n            }, zoomState));\n        },\n\n        /**\n         * Parse the given zoom value into a number to zoom to.\n         * @param   {float|string} val The zoom level (float or one of the zoom constants)\n         * @returns {float} The parsed zoom level\n         */\n        parseZoomValue: function (val) {\n            var zoomVal = parseFloat(val),\n                state = this.state,\n                zoomState = state.zoomState,\n                currentZoom = zoomState.zoom,\n                nextZoom = currentZoom;\n\n            // number\n            if (zoomVal) {\n                nextZoom = zoomVal;\n            } else {\n                switch (val) {\n                    case Crocodoc.ZOOM_FIT_WIDTH:\n                        // falls through\n                    case Crocodoc.ZOOM_FIT_HEIGHT:\n                        // falls through\n                    case Crocodoc.ZOOM_AUTO:\n                        nextZoom = this.calculateZoomValue(val);\n                        break;\n\n                    case Crocodoc.ZOOM_IN:\n                        // falls through\n                    case Crocodoc.ZOOM_OUT:\n                        nextZoom = this.calculateNextZoomLevel(val) || currentZoom;\n                        break;\n\n                    // bad mode or no value\n                    default:\n                        // if there hasn't been a zoom set yet\n                        if (!currentZoom) {\n                            //use default zoom\n                            nextZoom = this.calculateZoomValue(this.config.zoom || Crocodoc.ZOOM_AUTO);\n                        }\n                        else if (zoomState.zoomMode) {\n                            //adjust zoom\n                            nextZoom = this.calculateZoomValue(zoomState.zoomMode);\n                        } else {\n                            nextZoom = currentZoom;\n                        }\n                        break;\n                }\n            }\n\n            return nextZoom;\n        },\n\n        /**\n         * Calculates the new zoomMode given the input val and the parsed zoom value\n         * @param   {float|string} val  The input zoom value\n         * @param   {float} parsedZoom  The parsed zoom value\n         * @returns {string|null}       The new zoom move\n         */\n        calculateZoomMode: function (val, parsedZoom) {\n            // check if we landed on a named mode\n            switch (parsedZoom) {\n                case this.calculateZoomValue(Crocodoc.ZOOM_AUTO):\n                    // if the value passed is a named zoom mode, use that, because\n                    // fitheight and fitwidth can sometimes clash with auto (else use auto)\n                    if (typeof val === 'string' &&\n                        (val === Crocodoc.ZOOM_FIT_WIDTH || val === Crocodoc.ZOOM_FIT_HEIGHT))\n                    {\n                        return val;\n                    }\n                    return Crocodoc.ZOOM_AUTO;\n                case this.calculateZoomValue(Crocodoc.ZOOM_FIT_WIDTH):\n                    return Crocodoc.ZOOM_FIT_WIDTH;\n                case this.calculateZoomValue(Crocodoc.ZOOM_FIT_HEIGHT):\n                    return Crocodoc.ZOOM_FIT_HEIGHT;\n                default:\n                    return null;\n            }\n        },\n\n        /**\n         * Update zoom levels and the min and max zoom\n         * @returns {void}\n         */\n        updateZoomLevels: function () {\n            var i, lastZoomLevel,\n                zoomLevels = this.config.zoomLevels.slice() || [1],\n                auto = this.calculateZoomValue(Crocodoc.ZOOM_AUTO),\n                fitWidth = this.calculateZoomValue(Crocodoc.ZOOM_FIT_WIDTH),\n                fitHeight = this.calculateZoomValue(Crocodoc.ZOOM_FIT_HEIGHT),\n                presets = [fitWidth, fitHeight];\n\n            // update min and max zoom before adding presets into the mix\n            // because presets should not be able to override min/max zoom\n            this.state.minZoom = this.config.minZoom || zoomLevels[0];\n            this.state.maxZoom = this.config.maxZoom || zoomLevels[zoomLevels.length - 1];\n\n            // if auto is not the same as fitWidth or fitHeight,\n            // add it as a possible next zoom\n            if (auto !== fitWidth && auto !== fitHeight) {\n                presets.push(auto);\n            }\n\n            // add auto-zoom levels and sort\n            zoomLevels = zoomLevels.concat(presets);\n            zoomLevels.sort(function sortZoomLevels(a, b){\n                return a - b;\n            });\n\n            this.zoomLevels = [];\n\n            /**\n             * Return true if we should use this zoom level\n             * @param   {number} zoomLevel The zoom level to consider\n             * @returns {boolean}          True if we should keep this level\n             * @private\n             */\n            function shouldUseZoomLevel(zoomLevel) {\n                var similarity = lastZoomLevel / zoomLevel;\n                // remove duplicates\n                if (zoomLevel === lastZoomLevel) {\n                    return false;\n                }\n                // keep anything that is within the similarity threshold\n                if (similarity < ZOOM_LEVEL_SIMILARITY_THRESHOLD) {\n                    return true;\n                }\n                // check if it's a preset\n                if (util.inArray(zoomLevel, presets) > -1) {\n                    // keep presets if they are within a higher threshold\n                    if (similarity < ZOOM_LEVEL_PRESETS_SIMILARITY_THRESHOLD) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            // remove duplicates from sorted list, and remove unnecessary levels\n            // @NOTE: some zoom levels end up being very close to the built-in\n            // presets (fit-width/fit-height/auto), which makes zooming previous\n            // or next level kind of annoying when the zoom level barely changes.\n            // This fixes that by applying a threshold to the zoom levels to\n            // each preset, and removing the non-preset version if the\n            // ratio is below the threshold.\n            lastZoomLevel = 0;\n            for (i = 0; i < zoomLevels.length; ++i) {\n                if (shouldUseZoomLevel(zoomLevels[i])) {\n                    lastZoomLevel = zoomLevels[i];\n                    this.zoomLevels.push(lastZoomLevel);\n                }\n            }\n        },\n\n        /**\n         * Calculate the numeric value for a given zoom mode (or return the value if it's already numeric)\n         * @param   {string} mode The mode to zoom to\n         * @returns {float}       The zoom value\n         */\n        calculateZoomValue: function (mode) {\n            var state = this.state,\n                val = parseFloat(mode);\n            if (val) {\n                return val;\n            }\n            if (mode === Crocodoc.ZOOM_FIT_WIDTH) {\n                return state.viewportDimensions.clientWidth / state.widestPage.totalActualWidth;\n            }\n            else if (mode === Crocodoc.ZOOM_FIT_HEIGHT) {\n                return state.viewportDimensions.clientHeight / state.tallestPage.totalActualHeight;\n            }\n            else if (mode === Crocodoc.ZOOM_AUTO) {\n                return this.calculateZoomAutoValue();\n            } else {\n                return state.zoomState.zoom;\n            }\n        },\n\n        /**\n         * Apply the given zoom to the pages\n         * @param   {float} zoom The zoom value\n         * @returns {void}\n         */\n        applyZoom: function (zoom) {\n            applyZoomResize(this, zoom);\n        },\n\n        /**\n         * Scroll to the given value (page number or one of the scroll constants)\n         * @param   {int|string} val  The value to scroll to\n         * @returns {void}\n         */\n        scrollTo: function (val) {\n            var state = this.state,\n                pageNum = parseInt(val, 10);\n            if (typeof val === 'string') {\n                if (val === Crocodoc.SCROLL_PREVIOUS && state.currentPage > 1) {\n                    pageNum = this.calculatePreviousPage();\n                }\n                else if (val === Crocodoc.SCROLL_NEXT && state.currentPage < this.numPages) {\n                    pageNum = this.calculateNextPage();\n                }\n                else if (!pageNum) {\n                    return;\n                }\n            }\n            else if (!pageNum && pageNum !== 0) {\n                // pageNum is not a number\n                return;\n            }\n            pageNum = util.clamp(pageNum, 1, this.numPages);\n            this.scrollToPage(pageNum);\n        },\n\n        /**\n         * Scroll to the given page number\n         * @param   {int} page The page number to scroll to\n         * @returns {void}\n         */\n        scrollToPage: function (page) {\n            var offset = this.calculateScrollPositionForPage(page);\n            this.scrollToOffset(offset.left, offset.top);\n        },\n\n        /**\n         * Calculate which page is currently the \"focused\" page.\n         * By default, it's just the state's current page.\n         * @NOTE: this method will be overridden in most layouts.\n         * @returns {int} The current page\n         */\n        calculateCurrentPage: function () {\n            return this.state.currentPage;\n        },\n\n        /**\n         * Given a page number, return an object with top and left properties\n         * of the scroll position for that page\n         * @param   {int} pageNum The page number\n         * @returns {Object}      The scroll position object\n         */\n        calculateScrollPositionForPage: function (pageNum) {\n            var index = util.clamp(pageNum - 1, 0, this.numPages - 1),\n                page = this.state.pages[index];\n            return { top: page.y0, left: page.x0 };\n        },\n\n        /**\n         * Calculates the current range of pages that are visible\n         * @returns {Object} Range object with min and max values\n         */\n        calculateVisibleRange: function () {\n            var state = this.state,\n                pages = state.pages,\n                viewportHeight = state.viewportDimensions.clientHeight,\n                viewportWidth = state.viewportDimensions.clientWidth;\n\n            // no pages are visible, but this case breaks the logic below,\n            // becasue page widths/heights will also be 0\n            if (viewportWidth === 0 || viewportHeight === 0) {\n                return {\n                    min: -1,\n                    max: -1\n                };\n            }\n\n            var viewportY0 = state.scrollTop,\n                viewportY1 = viewportY0 + viewportHeight,\n                viewportX0 = state.scrollLeft,\n                viewportX1 = viewportX0 + viewportWidth,\n                lowY = util.bisectLeft(pages, viewportY0, 'y1'),\n                highY = util.bisectRight(pages, viewportY1, 'y0') - 1,\n                lowX = util.bisectLeft(pages, viewportX0, 'x1'),\n                highX = util.bisectRight(pages, viewportX1, 'x0') - 1,\n                low = Math.max(lowX, lowY),\n                high = Math.min(highX, highY);\n\n            return util.constrainRange(low, high, this.numPages - 1);\n        },\n\n        /**\n         * Calculates the current range of pages that are fully visible\n         * @returns {Object} Range object with min and max values\n         * @NOTE: the only difference between this and calculateVisibleRange is\n         * the bisectLeft/Right section below uses the opposite fields in the\n         * page objects to test against. (TODO) Consider refactoring this to\n         * make it a little simpler...\n         */\n        calculateFullyVisibleRange: function () {\n            var state = this.state,\n                pages = state.pages,\n                viewportHeight = state.viewportDimensions.clientHeight,\n                viewportWidth = state.viewportDimensions.clientWidth;\n\n            // no pages are visible, but this case breaks the logic below\n            // becasue page widths/heights will also be 0\n            if (viewportWidth === 0 || viewportHeight === 0) {\n                return {\n                    min: -1,\n                    max: -1\n                };\n            }\n\n            var viewportY0 = state.scrollTop,\n                viewportY1 = viewportY0 + viewportHeight,\n                viewportX0 = state.scrollLeft,\n                viewportX1 = viewportX0 + viewportWidth,\n                lowY = util.bisectLeft(pages, viewportY0, 'y0'),\n                highY = util.bisectRight(pages, viewportY1, 'y1') - 1,\n                lowX = util.bisectLeft(pages, viewportX0, 'x0'),\n                highX = util.bisectRight(pages, viewportX1, 'x1') - 1,\n                low = Math.max(lowX, lowY),\n                high = Math.min(highX, highY);\n\n            return util.constrainRange(low, high, this.numPages - 1);\n        },\n\n        /**\n         * Set the current page, update the visible pages, and broadcast a\n         * pagefocus  message if the given page is not already the current page\n         * @param {int} page The page number\n         */\n        setCurrentPage: function (page) {\n            var state = this.state;\n            if (state.currentPage !== page) {\n                // page has changed\n                state.currentPage = page;\n                this.updateVisiblePages();\n                scope.broadcast('pagefocus', {\n                    page: state.currentPage,\n                    numPages: this.numPages,\n                    visiblePages: util.extend([], state.visiblePages),\n                    fullyVisiblePages: util.extend([], state.fullyVisiblePages)\n                });\n            } else {\n                // still update visible pages!\n                this.updateVisiblePages();\n            }\n        },\n\n        /**\n         * Calculate and update which pages are visible,\n         * possibly updating CSS classes on the pages\n         * @param {boolean} updateClasses Wheter to update page CSS classes as well\n         * @returns {void}\n         */\n        updateVisiblePages: function (updateClasses) {\n            var i, len, $page,\n                state = this.state,\n                visibleRange = this.calculateVisibleRange(),\n                fullyVisibleRange = this.calculateFullyVisibleRange();\n            state.visiblePages.length = 0;\n            state.fullyVisiblePages.length = 0;\n            for (i = 0, len = this.$pages.length; i < len; ++i) {\n                $page = this.$pages.eq(i);\n                if (i < visibleRange.min || i > visibleRange.max) {\n                    if (updateClasses && $page.hasClass(CSS_CLASS_PAGE_VISIBLE)) {\n                        $page.removeClass(CSS_CLASS_PAGE_VISIBLE);\n                    }\n                } else {\n                    if (updateClasses && !$page.hasClass(CSS_CLASS_PAGE_VISIBLE)) {\n                        $page.addClass(CSS_CLASS_PAGE_VISIBLE);\n                    }\n                    state.visiblePages.push(i + 1);\n                }\n                if (i >= fullyVisibleRange.min && i <= fullyVisibleRange.max) {\n                    state.fullyVisiblePages.push(i + 1);\n                }\n            }\n        },\n\n        /**\n         * Update page positions, sizes, and rows\n         * @param {boolean} [forceUpdatePaddings] If true, force update page paddings\n         * @returns {void}\n         */\n        updatePageStates: function (forceUpdatePaddings) {\n            var state = this.state,\n                pages = state.pages,\n                rows = state.rows,\n                scrollTop = this.$viewport.scrollTop(),\n                scrollLeft = this.$viewport.scrollLeft(),\n                rowIndex = 0,\n                lastY1 = 0,\n                rightmostPageIndex = 0,\n                bottommostPageIndex = 0,\n                i,\n                len,\n                page,\n                pageEl,\n                $pageEl;\n\n            rows.length = state.sumWidths = state.sumHeights = state.totalWidth = state.totalHeight = 0;\n            state.widestPage.totalActualWidth = state.tallestPage.totalActualHeight = 0;\n\n            // update the x/y positions and sizes of each page\n            // this is basically used as a cache, since accessing the DOM is slow\n            for (i = 0, len = this.$pages.length; i < len; ++i) {\n                $pageEl = this.$pages.eq(i);\n                pageEl = $pageEl[0];\n                page = pages[i];\n                if (!page || forceUpdatePaddings) {\n                    $pageEl.css('padding', '');\n                    page = {\n                        index: i,\n                        // only get paddings on the first updatePageStates\n                        // @TODO: look into using numeric versions of these styles in IE for better perf\n                        paddingLeft: parseFloat($pageEl.css(STYLE_PADDING_LEFT)),\n                        paddingRight: parseFloat($pageEl.css(STYLE_PADDING_RIGHT)),\n                        paddingTop: parseFloat($pageEl.css(STYLE_PADDING_TOP)),\n                        paddingBottom: parseFloat($pageEl.css(STYLE_PADDING_BOTTOM))\n                    };\n                }\n\n                if (!page.actualWidth) {\n                    page.actualWidth = parseFloat(pageEl.getAttribute('data-width'));\n                }\n                if (!page.actualHeight) {\n                    page.actualHeight = parseFloat(pageEl.getAttribute('data-height'));\n                }\n\n                page.totalActualWidth = page.actualWidth + page.paddingLeft + page.paddingRight;\n                page.totalActualHeight = page.actualHeight + page.paddingTop + page.paddingBottom;\n\n                page.width = pageEl.offsetWidth;\n                page.height = pageEl.offsetHeight;\n                page.x0 = pageEl.offsetLeft;\n                page.y0 = pageEl.offsetTop;\n\n                page.x1 = page.width + page.x0;\n                page.y1 = page.height + page.y0;\n\n                // it is in the same rowIndex as the prev if y0 >= prev rowIndex max y1\n                // @NOTE: we add two pixels to y0, because sometimes there\n                // seems to be a little overlap #youcantexplainthat\n                // @TODO: #explainthat\n                if (lastY1 && getMaxY1InRow(pages, rows[rowIndex]) <= page.y0 + 2) {\n                    rowIndex++;\n                }\n                lastY1 = page.y1;\n                if (!rows[rowIndex]) {\n                    rows[rowIndex] = [];\n                }\n                // all pages are not created equal\n                if (page.totalActualWidth > state.widestPage.totalActualWidth) {\n                    state.widestPage = page;\n                }\n                if (page.totalActualHeight > state.tallestPage.totalActualHeight) {\n                    state.tallestPage = page;\n                }\n                state.sumWidths += page.width;\n                state.sumHeights += page.height;\n                page.rowIndex = rowIndex;\n                pages[i] = page;\n                rows[rowIndex].push(i);\n\n                if (pages[rightmostPageIndex].x0 + pages[rightmostPageIndex].width < page.x0 + page.width) {\n                    rightmostPageIndex = i;\n                }\n                if (pages[bottommostPageIndex].y0 + pages[bottommostPageIndex].height < page.y0 + page.height) {\n                    bottommostPageIndex = i;\n                }\n            }\n\n            state.totalWidth = pages[rightmostPageIndex].x0 + pages[rightmostPageIndex].width;\n            state.totalHeight = pages[bottommostPageIndex].y0 + pages[bottommostPageIndex].height;\n            state.scrollTop = scrollTop;\n            state.scrollLeft = scrollLeft;\n            this.setCurrentPage(this.calculateCurrentPage());\n        },\n\n        /**\n         * Calculate and update the current page\n         * @returns {void}\n         */\n        updateCurrentPage: function () {\n            var currentPage = this.calculateCurrentPage();\n            this.setCurrentPage(currentPage);\n        },\n\n        /**\n         * Handle resize messages\n         * @param   {Object} data Object containing width and height of the viewport\n         * @returns {void}\n         */\n        handleResize: function (data) {\n            var zoomMode = this.state.zoomState.zoomMode;\n            this.state.viewportDimensions = data;\n            this.updateZoomLevels();\n            this.setZoom(zoomMode);\n        },\n\n        /**\n         * Handle scrollend messages (forwarded to handleScroll)\n         * @param   {Object} data Object containing scrollTop and scrollLeft of the viewport\n         * @returns {void}\n         */\n        handleScrollEnd: function (data) {\n            // update CSS classes\n            this.$doc.find('.' + CSS_CLASS_CURRENT_PAGE).removeClass(CSS_CLASS_CURRENT_PAGE);\n            this.$pages.eq(this.state.currentPage - 1).addClass(CSS_CLASS_CURRENT_PAGE);\n            this.updateVisiblePages(true);\n            this.handleScroll(data);\n        },\n\n        /**\n         * Update the scroll position after a zoom\n         * @param {bool} shouldNotCenter Whether or not the scroll position\n         *                               should be updated to center the new\n         *                               zoom level\n         * @returns {void}\n         */\n        updateScrollPosition: function (shouldNotCenter) {\n            var state = this.state,\n                zoomState = state.zoomState,\n                ratio = zoomState.zoom / zoomState.prevZoom,\n                newScrollLeft, newScrollTop;\n\n            // update scroll position\n            newScrollLeft = state.scrollLeft * ratio;\n            newScrollTop = state.scrollTop * ratio;\n\n            // zoom to center\n            if (shouldNotCenter !== true) {\n                newScrollTop += state.viewportDimensions.offsetHeight * (ratio - 1) / 2;\n                newScrollLeft += state.viewportDimensions.offsetWidth * (ratio - 1) / 2;\n            }\n\n            // scroll!\n            this.scrollToOffset(newScrollLeft, newScrollTop);\n        },\n\n        /** MUST BE IMPLEMENTED IN LAYOUT **/\n        updateLayout: function () {},\n        calculateZoomAutoValue: function () { return 1; },\n        calculateNextPage: function () { return 1; },\n        calculatePreviousPage: function () { return 1; }\n    });\n});\n\n/**\n * The presentation-two-page layout\n */\nCrocodoc.addComponent('layout-' + LAYOUT_PRESENTATION_TWO_PAGE, ['layout-' + LAYOUT_PRESENTATION], function (scope, presentation) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var util = scope.getUtility('common');\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return presentation.extend({\n        /**\n         * Initialize the presentation-two-page layout component\n         * @returns {void}\n         */\n        init: function () {\n            this.twoPageMode = true;\n            presentation.init.call(this);\n        },\n\n        /**\n         * Calculates the next page\n         * @returns {int} The next page number\n         */\n        calculateNextPage: function () {\n            return this.state.currentPage + 2;\n        },\n\n        /**\n         * Calculates the previous page\n         * @returns {int} The previous page number\n         */\n        calculatePreviousPage: function () {\n            return this.state.currentPage - 2;\n        },\n\n        /**\n         * Calculate the numeric value for a given zoom mode (or return the value if it's already numeric)\n         * @param   {string} mode The mode to zoom to\n         * @returns {float}       The zoom value\n         */\n        calculateZoomValue: function (mode) {\n            var baseVal = presentation.calculateZoomValue.call(this, mode);\n            if (mode === ZOOM_FIT_WIDTH) {\n                baseVal /= 2;\n            }\n            return baseVal;\n        },\n\n        /**\n         * Scroll to the given page number\n         * @param   {int} page The page number to scroll to\n         * @returns {void}\n         */\n        scrollToPage: function (page) {\n            // pick the left page\n            presentation.scrollToPage.call(this, page - (page + 1) % 2);\n        },\n\n        /**\n         * Calculates the current range of pages that are visible\n         * @returns {Object} Range object with min and max values\n         */\n        calculateVisibleRange: function () {\n            var min = this.state.currentPage - 1,\n                max = min + 1;\n            return util.constrainRange(min, max, this.numPages);\n        },\n\n        /**\n         * Calculates the current range of pages that are fully visible\n         * @NOTE: this can be incorrect for presentations that are zoomed in\n         * past the size of the viewport... I'll fix it if it becomes an issue\n         * @returns {Object} Range object with min and max values\n         */\n        calculateFullyVisibleRange: function () {\n            return this.calculateVisibleRange();\n        }\n    });\n});\n\n/**\n *The presentation layout\n */\nCrocodoc.addComponent('layout-' + LAYOUT_PRESENTATION, ['layout-paged'], function (scope, paged) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var util = scope.getUtility('common');\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return paged.extend({\n        /**\n         * Initialize the presentation layout component\n         * @returns {void}\n         */\n        init: function () {\n            paged.init.call(this);\n            this.updatePageMargins();\n            this.updatePageClasses();\n        },\n\n        /**\n         * Destroy the component\n         * @returns {void}\n         */\n        destroy: function () {\n            paged.destroy.call(this);\n            this.$pages.css({ margin: '', left: '' }).removeClass(PRESENTATION_CSS_CLASSES);\n        },\n\n        /**\n         * Calculate the numeric value for zoom 'auto' for this layout mode\n         * @returns {float} The zoom value\n         */\n        calculateZoomAutoValue: function () {\n            var fitWidth = this.calculateZoomValue(ZOOM_FIT_WIDTH),\n                fitHeight = this.calculateZoomValue(ZOOM_FIT_HEIGHT);\n            return Math.min(fitWidth, fitHeight);\n        },\n\n        /**\n         * Calculate which page is currently the \"focused\" page.\n         * In presentation mode, it's just the state's current page.\n         * @returns {int} The current page\n         */\n        calculateCurrentPage: function () {\n            return this.state.currentPage;\n        },\n\n        /**\n         * Calculates the next page\n         * @returns {int} The next page number\n         */\n        calculateNextPage: function () {\n            return this.state.currentPage + 1;\n        },\n\n        /**\n         * Calculates the previous page\n         * @returns {int} The previous page number\n         */\n        calculatePreviousPage: function () {\n            return this.state.currentPage - 1;\n        },\n\n        /**\n         * Calculates the current range of pages that are visible\n         * @returns {Object} Range object with min and max values\n         */\n        calculateVisibleRange: function () {\n            var index = this.state.currentPage - 1;\n            return util.constrainRange(index, index, this.numPages);\n        },\n\n        /**\n         * Calculates the current range of pages that are fully visible\n         * @NOTE: this can be incorrect for presentations that are zoomed in\n         * past the size of the viewport... I'll fix it if it becomes an issue\n         * @returns {Object} Range object with min and max values\n         */\n        calculateFullyVisibleRange: function () {\n            return this.calculateVisibleRange();\n        },\n\n        /**\n         * Set the current page and updatePageClasses\n         * @param {int} page The page number\n         */\n        setCurrentPage: function (page) {\n            var index = util.clamp(page - 1, 0, this.numPages),\n                $precedingPage,\n                $currentPage;\n\n            paged.setCurrentPage.call(this, page);\n\n            // update CSS classes\n            this.$doc.find('.' + CSS_CLASS_PRECEDING_PAGE)\n                .removeClass(CSS_CLASS_PRECEDING_PAGE);\n\n            $precedingPage = this.$doc.find('.' + CSS_CLASS_CURRENT_PAGE);\n            $currentPage = this.$pages.eq(index);\n\n            if ($precedingPage[0] !== $currentPage[0]) {\n                $precedingPage\n                    .addClass(CSS_CLASS_PRECEDING_PAGE)\n                    .removeClass(CSS_CLASS_CURRENT_PAGE);\n                $currentPage.addClass(CSS_CLASS_CURRENT_PAGE);\n            }\n\n            this.updateVisiblePages(true);\n            this.updatePageClasses(index);\n        },\n\n        /**\n         * Scroll to the given page number\n         * @param   {int} page The page number to scroll to\n         * @returns {void}\n         */\n        scrollToPage: function (page) {\n            this.setCurrentPage(page);\n        },\n\n        /**\n         * Updates the layout elements (pages, doc, etc) CSS\n         * appropriately for the current zoom level\n         * @returns {void}\n         */\n        updateLayout: function () {\n            var state = this.state,\n                zoomState = state.zoomState,\n                zoom = zoomState.zoom,\n                page = this.currentPage || 1,\n                currentPage = state.pages[page - 1],\n                secondPage = this.twoPageMode ? state.pages[page] : currentPage,\n                viewportWidth = state.viewportDimensions.clientWidth,\n                viewportHeight = state.viewportDimensions.clientHeight,\n                secondPageWidth,\n                currentPageWidth,\n                currentPageHeight,\n                zoomedWidth, zoomedHeight,\n                docWidth, docHeight;\n\n            secondPageWidth = secondPage.actualWidth;\n            currentPageWidth = currentPage.actualWidth + (this.twoPageMode ? secondPageWidth : 0);\n            currentPageHeight = currentPage.actualHeight;\n\n            zoomedWidth = Math.floor((currentPageWidth + currentPage.paddingLeft + secondPage.paddingRight) * zoom);\n            zoomedHeight = Math.floor((currentPage.totalActualHeight) * zoom);\n\n            docWidth = Math.max(zoomedWidth, viewportWidth);\n            docHeight = Math.max(zoomedHeight, viewportHeight);\n\n            this.$doc.css({\n                width: docWidth,\n                height: docHeight\n            });\n\n            this.updatePageMargins();\n\n            if (docWidth > viewportWidth || docHeight > viewportHeight) {\n                this.$el.addClass('crocodoc-scrollable');\n            } else {\n                this.$el.removeClass('crocodoc-scrollable');\n            }\n        },\n\n        /**\n         * Update page margins for the viewport size and zoom level\n         * @returns {void}\n         */\n        updatePageMargins: function () {\n            var i, len, page, $page,\n                width, height, left, top, paddingH,\n                state = this.state,\n                viewportWidth = state.viewportDimensions.clientWidth,\n                viewportHeight = state.viewportDimensions.clientHeight;\n            // update pages so they are centered (preserving margins)\n            for (i = 0, len = this.$pages.length; i < len; ++i) {\n                $page = this.$pages.eq(i);\n                page = state.pages[i];\n\n                if (this.twoPageMode) {\n                    paddingH = (i % 2 === 1) ? page.paddingRight : page.paddingLeft;\n                } else {\n                    paddingH = page.paddingRight + page.paddingLeft;\n                }\n                width = (page.actualWidth + paddingH) * state.zoomState.zoom;\n                height = (page.actualHeight + page.paddingTop + page.paddingBottom) * state.zoomState.zoom;\n\n                if (this.twoPageMode) {\n                    left = Math.max(0, (viewportWidth - width * 2) / 2);\n                    if (i % 2 === 1) {\n                        left += width;\n                    }\n                } else {\n                    left = (viewportWidth - width) / 2;\n                }\n                top = (viewportHeight - height) / 2;\n                left = Math.max(left, 0);\n                top = Math.max(top, 0);\n                $page.css({\n                    marginLeft: left,\n                    marginTop: top\n                });\n            }\n        },\n\n        /**\n         * Update page classes for presentation mode transitions\n         * @returns {void}\n         */\n        updatePageClasses: function () {\n            var $pages = this.$pages,\n                index = this.state.currentPage - 1,\n                next = index + 1,\n                prev = index - 1,\n                buffer = 20;\n\n            // @TODO: optimize this a bit\n            // add/removeClass is expensive, so try using hasClass\n            $pages.removeClass(PRESENTATION_CSS_CLASSES);\n            if (this.twoPageMode) {\n                next = index + 2;\n                prev = index - 2;\n                $pages.slice(Math.max(prev, 0), index).addClass(CSS_CLASS_PAGE_PREV);\n                $pages.slice(next, next + 2).addClass(CSS_CLASS_PAGE_NEXT);\n            } else {\n                if (prev >= 0) {\n                    $pages.eq(prev).addClass(CSS_CLASS_PAGE_PREV);\n                }\n                if (next < this.numPages) {\n                    $pages.eq(next).addClass(CSS_CLASS_PAGE_NEXT);\n                }\n            }\n            $pages.slice(0, index).addClass(CSS_CLASS_PAGE_BEFORE);\n            $pages.slice(Math.max(0, index - buffer), index).addClass(CSS_CLASS_PAGE_BEFORE_BUFFER);\n            $pages.slice(next).addClass(CSS_CLASS_PAGE_AFTER);\n            $pages.slice(next, Math.min(this.numPages, next + buffer)).addClass(CSS_CLASS_PAGE_AFTER_BUFFER);\n\n            /*\n            // OPTIMIZATION CODE NOT YET WORKING PROPERLY\n            $pages.slice(0, index).each(function () {\n                var $p = $(this),\n                    i = $p.index(),\n                    toAdd = '',\n                    toRm = '';\n                if (!$p.hasClass(beforeClass.trim())) toAdd += beforeClass;\n                if ($p.hasClass(nextClass.trim())) toRm += nextClass;\n                if ($p.hasClass(afterClass.trim())) toRm += afterClass;\n                if ($p.hasClass(afterBufferClass.trim())) toRm += afterBufferClass;\n                if (i >= index - buffer && !$p.hasClass(beforeBufferClass.trim()))\n                    toAdd += beforeBufferClass;\n                else if ($p.hasClass(beforeBufferClass.trim()))\n                    toRm += beforeBufferClass;\n                if (i >= prev && !$p.hasClass(prevClass.trim()))\n                    toAdd += prevClass;\n                else if ($p.hasClass(prevClass.trim()))\n                    toRm += prevClass;\n                $p.addClass(toAdd).removeClass(toRm);\n//                console.log('before', $p.index(), toRm, toAdd);\n            });\n            $pages.slice(next).each(function () {\n                var $p = $(this),\n                    i = $p.index(),\n                    toAdd = '',\n                    toRm = '';\n                if (!$p.hasClass(afterClass.trim())) toAdd += afterClass;\n                if ($p.hasClass(prevClass.trim())) toRm += prevClass;\n                if ($p.hasClass(beforeClass.trim())) toRm += beforeClass;\n                if ($p.hasClass(beforeBufferClass.trim())) toRm += beforeBufferClass;\n                if (i <= index + buffer && !$p.hasClass(afterBufferClass.trim()))\n                    toAdd += afterBufferClass;\n                else if ($p.hasClass(afterBufferClass.trim()))\n                    toRm += afterBufferClass;\n                if (i <= next + 1 && !$p.hasClass(nextClass.trim()))\n                    toAdd += nextClass;\n                else if ($p.hasClass(nextClass.trim()))\n                    toRm += nextClass;\n                $p.addClass(toAdd).removeClass(toRm);\n//                console.log('after', $p.index(), toRm, toAdd);\n            });*/\n        }\n    });\n});\n\n/**\n * Layout for text-based files\n */\nCrocodoc.addComponent('layout-' + LAYOUT_TEXT, ['layout-base'], function (scope, base) {\n    'use strict';\n\n    var util = scope.getUtility('common');\n\n    return base.extend({\n        init: function () {\n            base.init.call(this);\n            this.zoomLevels = this.config.zoomLevels.slice();\n            this.minZoom = this.zoomLevels[0];\n            this.maxZoom = this.zoomLevels[this.zoomLevels.length - 1];\n        },\n\n        setZoom: function (val) {\n            var z,\n                zoomState = this.state.zoomState,\n                currentZoom = zoomState.zoom;\n\n            if (typeof val === 'string') {\n                z = this.calculateNextZoomLevel(val);\n                if (!z) {\n                    if (val === 'auto' || val === 'fitwidth' || val === 'fitheight') {\n                        z = 1;\n                    } else {\n                        z = currentZoom;\n                    }\n                }\n            } else {\n                z = parseFloat(val) || currentZoom;\n            }\n\n            z = util.clamp(z, this.minZoom, this.maxZoom);\n            this.config.$doc.css('font-size', (z * 10) + 'pt');\n\n            zoomState.prevZoom = currentZoom;\n            zoomState.zoom = z;\n            zoomState.canZoomIn = this.calculateNextZoomLevel(Crocodoc.ZOOM_IN) !== false;\n            zoomState.canZoomOut = this.calculateNextZoomLevel(Crocodoc.ZOOM_OUT) !== false;\n\n            scope.broadcast('zoom', util.extend({\n                isDraggable: this.isDraggable()\n            }, zoomState));\n        }\n    });\n});\n\n/**\n * The vertical-single-column layout\n */\nCrocodoc.addComponent('layout-' + LAYOUT_VERTICAL_SINGLE_COLUMN, ['layout-' + LAYOUT_VERTICAL], function (scope, vertical) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    // there is nothing different about this layout aside from the name (and CSS class name)\n    // so we can just return the vertical layout\n    return vertical;\n});\n\n/**\n * The vertical layout\n */\nCrocodoc.addComponent('layout-' + LAYOUT_VERTICAL, ['layout-paged'], function (scope, paged) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var util = scope.getUtility('common'),\n        browser = scope.getUtility('browser');\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return paged.extend({\n\n        /**\n         * Calculate the numeric value for zoom 'auto' for this layout mode\n         * @returns {float} The zoom value\n         */\n        calculateZoomAutoValue: function () {\n            var state = this.state,\n                fitWidth = this.calculateZoomValue(ZOOM_FIT_WIDTH),\n                fitHeight = this.calculateZoomValue(ZOOM_FIT_HEIGHT);\n\n            if (state.widestPage.actualWidth > state.tallestPage.actualHeight) {\n                // landscape\n                // max zoom 1 for vertical mode\n                return Math.min(1, fitWidth, fitHeight);\n            } else {\n                // portrait\n                if (browser.mobile) {\n                    return fitWidth;\n                }\n                // limit max zoom to 100% of the doc\n                return Math.min(1, fitWidth);\n            }\n        },\n\n        /**\n         * Calculate which page is currently the \"focused\" page.\n         * In vertical mode, this is the page at the top (and if multiple columns, the leftmost page),\n         * where at least half of the page is showing.\n         * @returns {int} The current page\n         */\n        calculateCurrentPage: function () {\n            var prevPageIndex,\n                currentPageIndex,\n                rowIndex,\n                row,\n                offset,\n                state = this.state,\n                pages = state.pages;\n\n            prevPageIndex = util.bisectRight(pages, state.scrollTop, 'y0') - 1;\n            if (prevPageIndex < 0) {\n                return 1;\n            }\n            offset = state.scrollTop + pages[prevPageIndex].height / 2;\n            currentPageIndex = util.bisectRight(pages, offset, 'y0') - 1;\n            rowIndex = pages[currentPageIndex].rowIndex;\n            row = state.rows[rowIndex];\n            return 1 + row[0];\n\n        },\n\n        /**\n         * Calculates the next page\n         * @returns {int} The next page number\n         */\n        calculateNextPage: function () {\n            var state = this.state,\n                currentPage = state.pages[state.currentPage - 1],\n                rowIndex = currentPage.rowIndex,\n                nextRow = state.rows[rowIndex + 1];\n            return nextRow && nextRow[0] + 1 || state.currentPage;\n        },\n\n        /**\n         * Calculates the previous page\n         * @returns {int} The previous page number\n         */\n        calculatePreviousPage: function () {\n            var state = this.state,\n                currentPage = state.pages[state.currentPage - 1],\n                rowIndex = currentPage.rowIndex,\n                prevRow = state.rows[rowIndex - 1];\n            return prevRow && prevRow[0] + 1 || state.currentPage;\n        },\n\n        /**\n         * Handle resize mesages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handleResize: function (data) {\n            paged.handleResize.call(this, data);\n            this.updateCurrentPage();\n        },\n\n        /**\n         * Handle scroll mesages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handleScroll: function (data) {\n            paged.handleScroll.call(this, data);\n            this.updateCurrentPage();\n        },\n\n        /**\n         * Updates the layout elements (pages, doc, etc) CSS\n         * appropriately for the current zoom level\n         * @returns {void}\n         */\n        updateLayout: function () {\n            // vertical stuff\n            var state = this.state,\n                zoom = state.zoomState.zoom,\n                zoomedWidth,\n                docWidth;\n\n            zoomedWidth = Math.floor(state.widestPage.totalActualWidth * zoom);\n\n            // use clientWidth for the doc (prevent scrollbar)\n            // use width:auto when possible\n            if (zoomedWidth <= state.viewportDimensions.clientWidth) {\n                docWidth = 'auto';\n            } else {\n                docWidth = zoomedWidth;\n            }\n\n            this.$doc.css({\n                width: docWidth\n            });\n        }\n    });\n});\n\n\n/*global setTimeout, clearTimeout*/\n\n/**\n * lazy-loader component for controlling when pages should be loaded and unloaded\n */\nCrocodoc.addComponent('lazy-loader', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var util = scope.getUtility('common'),\n        browser = scope.getUtility('browser'),\n        api = {},\n        pages,\n        numPages,\n        pagefocusTriggerLoadingTID,\n        readyTriggerLoadingTID,\n        pageLoadTID,\n        pageLoadQueue = [],\n        pageLoadRange = 1,\n        pageLoadingStopped = true,\n        scrollDirection = 1,\n        ready = false,\n        layoutState = {\n            page: 1,\n            visiblePages: [1]\n        };\n\n    /**\n     * Create and return a range object (eg., { min: x, max: y })\n     * for the current pageLoadRange constrained to the number of pages\n     * @param  {int} range The range from current page\n     * @returns {Object}    The range object\n     * @private\n     */\n    function calculateRange(range) {\n        range = range || pageLoadRange;\n        var currentIndex = layoutState.page - 1,\n            low = currentIndex - range,\n            high = currentIndex + range;\n        return util.constrainRange(low, high, numPages - 1);\n    }\n\n    /**\n     * Loop through the pageLoadQueue and load pages sequentially,\n     * setting a timeout to run again after PAGE_LOAD_INTERVAL ms\n     * until the queue is empty\n     * @returns {void}\n     * @private\n     */\n    function pageLoadLoop() {\n        var index;\n        clearTimeout(pageLoadTID);\n        if (pageLoadQueue.length > 0) {\n            // found a page to load\n            index = pageLoadQueue.shift();\n            // page exists and not reached max errors?\n            if (pages[index]) {\n                api.loadPage(index, function loadPageCallback(pageIsLoading) {\n                    if (pageIsLoading === false) {\n                        // don't wait if the page is not loading\n                        pageLoadLoop();\n                    } else {\n                        pageLoadTID = setTimeout(pageLoadLoop, PAGE_LOAD_INTERVAL);\n                    }\n                });\n            } else {\n                pageLoadLoop();\n            }\n        } else {\n            stopPageLoadLoop();\n        }\n    }\n\n    /**\n     * Start the page load loop\n     * @returns {void}\n     * @private\n     */\n    function startPageLoadLoop() {\n        clearTimeout(pageLoadTID);\n        pageLoadingStopped = false;\n        pageLoadTID = setTimeout(pageLoadLoop, PAGE_LOAD_INTERVAL);\n    }\n\n    /**\n     * Stop the page load loop\n     * @returns {void}\n     * @private\n     */\n    function stopPageLoadLoop() {\n        clearTimeout(pageLoadTID);\n        pageLoadingStopped = true;\n    }\n\n    /**\n     * Add a page to the page load queue and start the page\n     * load loop if necessary\n     * @param  {int} index The index of the page to add\n     * @returns {void}\n     * @private\n     */\n    function pushPageLoadQueue(index) {\n        pageLoadQueue.push(index);\n        if (pageLoadingStopped) {\n            startPageLoadLoop();\n        }\n    }\n\n    /**\n     * Clear all pages from the page load queue and stop the loop\n     * @returns {void}\n     * @private\n     */\n    function clearPageLoadQueue() {\n        pageLoadQueue.length = 0;\n        stopPageLoadLoop();\n    }\n\n    /**\n     * Returns true if the given index is in the page load range, and false otherwise\n     * @param   {int} index The page index\n     * @param   {int} rangeLength The page range length\n     * @returns {bool}      Whether the page index is in the page load range\n     * @private\n     */\n    function indexInRange(index, rangeLength) {\n        var range = calculateRange(rangeLength);\n        if (index >= range.min && index <= range.max) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the given page index should be loaded, and false otherwise\n     * @param   {int} index The page index\n     * @returns {bool}      Whether the page should be loaded\n     * @private\n     */\n    function shouldLoadPage(index) {\n        var page = pages[index];\n\n        // does the page exist?\n        if (page) {\n\n            // within page load range?\n            if (indexInRange(index)) {\n                return true;\n            }\n\n            // is it visible?\n            if (pageIsVisible(index)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the given page index should be unloaded, and false otherwise\n     * @param   {int} index The page index\n     * @param   {int} rangeLength The range length\n     * @returns {bool}      Whether the page should be unloaded\n     * @private\n     */\n    function shouldUnloadPage(index, rangeLength) {\n\n        // within page load range?\n        if (indexInRange(index, rangeLength)) {\n            return false;\n        }\n\n        // is it visible?\n        if (pageIsVisible(index)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns true if the given page is visible, and false otherwise\n     * @param   {int} index The page index\n     * @returns {bool}      Whether the page is visible\n     * @private\n     */\n    function pageIsVisible(index) {\n        // is it visible?\n        return util.inArray(index + 1, layoutState.visiblePages) > -1;\n    }\n\n    /**\n     * Queues pages to load in order from indexFrom to indexTo\n     * @param   {number} start The page index to start at\n     * @param   {number} end   The page index to end at\n     * @returns {void}\n     */\n    function queuePagesToLoadInOrder(start, end) {\n        var increment = util.sign(end - start);\n\n        while (start !== end) {\n            api.queuePageToLoad(start);\n            start += increment;\n        }\n        api.queuePageToLoad(start);\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return util.extend(api, {\n        messages: [\n            'beforezoom',\n            'pageavailable',\n            'pagefocus',\n            'ready',\n            'scroll',\n            'scrollend',\n            'zoom'\n        ],\n\n        /**\n         * Handle framework messages\n         * @param {string} name The name of the message\n         * @param {Object} data The related data for the message\n         * @returns {void}\n         */\n        onmessage: function (name, data) {\n            switch (name) {\n                case 'beforezoom':\n                    this.handleBeforeZoom(data);\n                    break;\n                case 'pageavailable':\n                    this.handlePageAvailable(data);\n                    break;\n                case 'pagefocus':\n                    this.handlePageFocus(data);\n                    break;\n                case 'ready':\n                    this.handleReady();\n                    break;\n                case 'scroll':\n                    this.handleScroll();\n                    break;\n                case 'scrollend':\n                    this.handleScrollEnd();\n                    break;\n                case 'zoom':\n                    this.handleZoom(data);\n                    break;\n                // no default\n            }\n        },\n\n        /**\n         * Initialize the LazyLoader component\n         * @param {Array} pageComponents The array of page components to lazily load\n         * @returns {void}\n         */\n        init: function (pageComponents) {\n            pages = pageComponents;\n            numPages = pages.length;\n            pageLoadRange = (browser.mobile || browser.ielt10) ?\n                MAX_PAGE_LOAD_RANGE_MOBILE :\n                MAX_PAGE_LOAD_RANGE;\n            pageLoadRange = Math.min(pageLoadRange, numPages);\n        },\n\n        /**\n         * Destroy the LazyLoader component\n         * @returns {void}\n         */\n        destroy: function () {\n            this.cancelAllLoading();\n        },\n\n        /**\n         * Updates the current layout state and scroll direction\n         * @param   {Object} state The layout state\n         * @returns {void}\n         */\n        updateLayoutState: function (state) {\n            scrollDirection = util.sign(state.page - layoutState.page);\n            layoutState = state;\n        },\n\n        /**\n         * Queue pages to load in the following order:\n         * 1) current page\n         * 2) visible pages\n         * 3) pages within pageLoadRange of the viewport\n         * @returns {void}\n         * @NOTE: this function is debounced so it will not load and abort\n         * several times if called a lot in a short time\n         */\n        loadNecessaryPages: util.debounce(100, function () {\n            // cancel anything that happens to be loading first\n            this.cancelAllLoading();\n\n            // load current page first\n            this.queuePageToLoad(layoutState.page - 1);\n\n            // then load pages that are visible in the viewport\n            this.loadVisiblePages();\n\n            // then load pages beyond the viewport\n            this.loadPagesInRange(pageLoadRange);\n        }),\n\n        /**\n         * Queue pages to load within the given range such that\n         * proceeding pages are added before preceding pages\n         * @param  {int} range The range to load beyond the current page\n         * @returns {void}\n         */\n        loadPagesInRange: function (range) {\n            var currentIndex = layoutState.page - 1;\n            if (range > 0) {\n                range = calculateRange(range);\n                // load pages in the order of priority based on the direction\n                // the user is scrolling (load nearest page first, working in\n                // the scroll direction, then start on the opposite side of\n                // scroll direction and work outward)\n                // NOTE: we're assuming that a negative scroll direction means\n                // direction of previous pages, and positive is next pages...\n                if (scrollDirection >= 0) {\n                    queuePagesToLoadInOrder(currentIndex + 1, range.max);\n                    queuePagesToLoadInOrder(currentIndex - 1, range.min);\n                } else {\n                    queuePagesToLoadInOrder(currentIndex - 1, range.min);\n                    queuePagesToLoadInOrder(currentIndex + 1, range.max);\n                }\n            }\n        },\n\n        /**\n         * Queue to load all pages that are visible according\n         * to the current layoutState\n         * @returns {void}\n         */\n        loadVisiblePages: function () {\n            var i, len;\n            for (i = 0, len = layoutState.visiblePages.length; i < len; ++i) {\n                this.queuePageToLoad(layoutState.visiblePages[i] - 1);\n            }\n        },\n\n        /**\n         * Add the page at the given index to the page load queue\n         * and call the preload function on the page\n         * @param  {int} index The index of the page to load\n         * @returns {void}\n         */\n        queuePageToLoad: function (index) {\n            if (shouldLoadPage(index)) {\n                pages[index].preload();\n                pushPageLoadQueue(index);\n            }\n        },\n\n        /**\n         * Clear the page load queue\n         * @returns {void}\n         */\n        cancelAllLoading: function () {\n            clearTimeout(readyTriggerLoadingTID);\n            clearTimeout(pagefocusTriggerLoadingTID);\n            clearPageLoadQueue();\n        },\n\n        /**\n         * Call the load method on the page object at the specified index\n         * @param  {int}      index    The index of the page to load\n         * @param  {Function} callback Callback function to call always (regardless of page load success/fail)\n         * @returns {void}\n         */\n        loadPage: function (index, callback) {\n            $.when(pages[index] && pages[index].load())\n                .always(callback);\n        },\n\n        /**\n         * Call the unload method on the page object at the specified index\n         * @param  {int} index The page index\n         * @returns {void}\n         */\n        unloadPage: function (index) {\n            var page = pages[index];\n            if (page) {\n                page.unload();\n            }\n        },\n\n        /**\n         * Unload all pages that are not within the given range (nor visible)\n         * @param {int} rangeLength The page range length\n         * @returns {void}\n         */\n        unloadUnnecessaryPages: function (rangeLength) {\n            var i, l;\n            // remove out-of-range SVG from DOM\n            for (i = 0, l = pages.length; i < l; ++i) {\n                if (shouldUnloadPage(i, rangeLength)) {\n                    this.unloadPage(i);\n                }\n            }\n        },\n\n        /**\n         * Handle ready messages\n         * @returns {void}\n         */\n        handleReady: function () {\n            ready = true;\n            this.loadVisiblePages();\n            readyTriggerLoadingTID = setTimeout(function () {\n                api.loadNecessaryPages();\n            }, READY_TRIGGER_PRELOADING_DELAY);\n        },\n\n        /**\n         * Handle pageavailable messages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handlePageAvailable: function (data) {\n            if (!ready) {\n                return;\n            }\n            var i;\n            if (data.all === true) {\n                data.upto = numPages;\n            }\n            if (data.page) {\n                this.queuePageToLoad(data.page - 1);\n            } else if (data.upto) {\n                for (i = 0; i < data.upto; ++i) {\n                    this.queuePageToLoad(i);\n                }\n            }\n        },\n\n        /**\n         * Handle pagefocus messages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handlePageFocus: function (data) {\n            // NOTE: update layout state before `ready`\n            this.updateLayoutState(data);\n            if (!ready) {\n                return;\n            }\n            this.cancelAllLoading();\n            // set a timeout to trigger loading so we dont cause unnecessary layouts while scrolling\n            pagefocusTriggerLoadingTID = setTimeout(function () {\n                api.loadNecessaryPages();\n            }, 200);\n        },\n\n        /**\n         * Handle beforezoom messages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handleBeforeZoom: function (data) {\n            if (!ready) {\n                return;\n            }\n            this.cancelAllLoading();\n            // @NOTE: for performance reasons, we unload as many pages as possible just before zooming\n            // so we don't have to layout as many pages at a time immediately after the zoom.\n            // This is arbitrarily set to 2x the number of visible pages before the zoom, and\n            // it seems to work alright.\n            this.unloadUnnecessaryPages(data.visiblePages.length * 2);\n        },\n\n        /**\n         * Handle zoom messages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handleZoom: function (data) {\n            // NOTE: update layout state before `ready`\n            this.updateLayoutState(data);\n            if (!ready) {\n                return;\n            }\n            this.loadNecessaryPages();\n        },\n\n        /**\n         * Handle scroll messages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handleScroll: function () {\n            this.cancelAllLoading();\n        },\n\n        /**\n         * Handle scrollend messages\n         * @param   {Object} data The message data\n         * @returns {void}\n         */\n        handleScrollEnd: function () {\n            if (!ready) {\n                return;\n            }\n            this.loadNecessaryPages();\n            this.unloadUnnecessaryPages(pageLoadRange);\n        }\n    });\n});\n\n/**\n * page-img component used to display raster image instead of SVG content for\n * browsers that do not support SVG\n */\nCrocodoc.addComponent('page-img', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var browser = scope.getUtility('browser');\n\n    var $img, $el,\n        $loadImgPromise,\n        page,\n        imageLoaded = false,\n        removeOnUnload = browser.mobile;\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Initialize the page-img component\n         * @param  {Element} el     The element to insert the image into\n         * @param  {number} pageNum The page number\n         * @returns {void}\n         */\n        init: function (el, pageNum) {\n            $el = $(el);\n            page = pageNum;\n        },\n\n        /**\n         * Destroy the page-img component\n         * @returns {void}\n         */\n        destroy: function () {\n            removeOnUnload = true;\n            this.unload();\n            $el.empty();\n        },\n\n        /**\n         * Prepare the element for loading\n         * @returns {void}\n         */\n        prepare: function () { /* noop */ },\n\n        /**\n         * Preload the image\n         * @returns {void}\n         */\n        preload: function () {\n            if (!$loadImgPromise) {\n                $loadImgPromise = scope.get('page-img', page);\n            }\n        },\n\n        /**\n         * Load the image\n         * @returns {$.Promise}    A jQuery Promise object\n         */\n        load: function () {\n            this.preload();\n\n            $loadImgPromise.done(function loadImgSuccess(img) {\n                if (!imageLoaded) {\n                    imageLoaded = true;\n                    $img = $(img).appendTo($el);\n                }\n            });\n\n            $loadImgPromise.fail(function loadImgFail(error) {\n                imageLoaded = false;\n                if (error) {\n                    scope.broadcast('asseterror', error);\n                }\n            });\n\n            return $loadImgPromise;\n        },\n\n        /**\n         * Unload the img if necessary\n         * @returns {void}\n         */\n        unload: function () {\n            if ($loadImgPromise) {\n                $loadImgPromise.abort();\n                $loadImgPromise = null;\n            }\n            if (removeOnUnload) {\n                if ($img) {\n                    $img.remove();\n                    $img = null;\n                }\n                imageLoaded = false;\n            }\n        }\n    };\n});\n\n/**\n * page-links component definition\n */\nCrocodoc.addComponent('page-links', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var $el,\n        browser = scope.getUtility('browser');\n\n    /**\n     * Create a link element given link data\n     * @param   {Object} link The link data\n     * @returns {void}\n     * @private\n     */\n    function createLink(link) {\n        var $link = $('<a>').addClass(CSS_CLASS_PAGE_LINK),\n            left = link.bbox[0],\n            top = link.bbox[1],\n            attr = {};\n\n        if (browser.ie) {\n            // @NOTE: IE doesn't allow override of ctrl+click on anchor tags,\n            // but there is a workaround to add a child element (which triggers\n            // the onclick event first)\n            $('<span>')\n                .appendTo($link)\n                .on('click', handleClick);\n        }\n\n        $link.css({\n            left: left + 'pt',\n            top: top + 'pt',\n            width: link.bbox[2] - left + 'pt',\n            height: link.bbox[3] - top + 'pt'\n        });\n\n        if (link.uri) {\n            if (/^http|^mailto/.test(link.uri)) {\n                attr.href = encodeURI(link.uri);\n                attr.target = '_blank';\n            } else {\n                // don't embed this link... we don't trust the protocol\n                return;\n            }\n        } else if (link.destination) {\n            attr.href = '#page-' + link.destination.pagenum;\n        }\n\n        $link.attr(attr);\n        $link.data('link', link);\n        $link.appendTo($el);\n    }\n\n    /**\n     * Handle link clicks\n     * @param   {Event} event The event object\n     * @returns {void}\n     * @private\n     */\n    function handleClick(event) {\n        var targetEl = browser.ie ? event.target.parentNode : event.target,\n            $link = $(targetEl),\n            data = $link.data('link');\n\n        if (data) {\n            scope.broadcast('linkclick', data);\n        }\n        event.preventDefault();\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Initialize the page-links component\n         * @param  {Array} links Links configuration array\n         * @returns {void}\n         * @TODO (possible): make a links data-provider instead of passing\n         * them in as an argument?\n         */\n        init: function (el, links) {\n            $el = $(el);\n            this.createLinks(links);\n            if (!browser.ie) {\n                // @NOTE: event handlers are individually bound in IE, because\n                // the ctrl+click workaround fails when using event delegation\n                $el.on('click', '.' + CSS_CLASS_PAGE_LINK, handleClick);\n            }\n        },\n\n        /**\n         * Destroy the page-links component\n         * @returns {void}\n         */\n        destroy: function () {\n            // @NOTE: individual click event handlers needed for IE are\n            // implicitly removed by jQuery when we empty the links container\n            $el.empty().off('click');\n            $el = browser = null;\n        },\n\n        /**\n         * Create and insert link elements into the element\n         * @param   {Array} links Array of link data\n         * @returns {void}\n         */\n        createLinks: function (links) {\n            var i, len;\n            for (i = 0, len = links.length; i < len; ++i) {\n                createLink(links[i]);\n            }\n        }\n    };\n});\n\n/**\n * page-svg component\n */\nCrocodoc.addComponent('page-svg', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var browser = scope.getUtility('browser'),\n        DOMParser = window.DOMParser;\n\n    var $svg, $svgLayer,\n        $loadSVGPromise,\n        page,\n        destroyed = false,\n        unloaded = false,\n        svgLoaded = false,\n        viewerConfig = scope.getConfig(),\n        removeOnUnload = browser.mobile || browser.ielt10,\n        // * IE 9-10 and firefox perform better with <img> elements\n        // * IE 11 crashes when using img elements for some reason\n        // * Everything else is happy with iframe + innerhtml\n        embedStrategy = browser.ielt11 || browser.firefox ?\n                        EMBED_STRATEGY_DATA_URL_IMG :\n                        EMBED_STRATEGY_IFRAME_INNERHTML;\n\n    /**\n     * Create and return a jQuery object for the SVG element\n     * @returns {Object} The SVG $element\n     * @private\n     */\n    function createSVGEl() {\n        switch (embedStrategy) {\n            case EMBED_STRATEGY_IFRAME_INNERHTML:\n            case EMBED_STRATEGY_IFRAME_PROXY:\n                return $('<iframe>');\n\n            case EMBED_STRATEGY_DATA_URL_PROXY:\n            case EMBED_STRATEGY_DATA_URL:\n                return $('<object>').attr({\n                    type: SVG_MIME_TYPE,\n                    data: 'data:'+SVG_MIME_TYPE+';base64,' + window.btoa(SVG_CONTAINER_TEMPLATE)\n                });\n\n            case EMBED_STRATEGY_INLINE_SVG:\n                return $('<div>');\n\n            case EMBED_STRATEGY_BASIC_OBJECT:\n                return $('<object>');\n\n            case EMBED_STRATEGY_BASIC_IMG:\n            case EMBED_STRATEGY_DATA_URL_IMG:\n                return $('<img>');\n\n            // no default\n        }\n    }\n\n    /**\n     * Create the svg element if it hasn't been created,\n     * insert the SVG into the DOM if necessary\n     * @returns {void}\n     * @private\n     */\n    function prepareSVGContainer() {\n        if (!$svg || $svg.length === 0) {\n            svgLoaded = false;\n            $svg = createSVGEl();\n        }\n        if ($svg.parent().length === 0) {\n            $svg.appendTo($svgLayer);\n        }\n    }\n\n    /**\n     * Load svg text if necessary\n     * @returns {$.Promise}\n     * @private\n     */\n    function loadSVGText() {\n        if (svgLoaded ||\n            // @NOTE: these embed strategies don't require svg text to be loaded\n            embedStrategy === EMBED_STRATEGY_BASIC_OBJECT ||\n            embedStrategy === EMBED_STRATEGY_BASIC_IMG)\n        {\n            // don't load the SVG text, just return an empty promise\n            return $.Deferred().resolve().promise({\n                abort: function() {}\n            });\n        } else {\n            return scope.get('page-svg', page);\n        }\n    }\n\n    /**\n     * Fixes a bug in Safari where <use> elements are not supported properly\n     * by replacing each <use> element with a clone of its referenced <image>\n     * @param   {Document} contentDocument The SVG document\n     * @returns {void}\n     */\n    function fixUseElements(contentDocument) {\n        // find all <use> elements\n        var useEls = contentDocument.querySelectorAll('use');\n        [].forEach.call(useEls, function (use) {\n            var id = use.getAttribute('xlink:href'),\n                // clone the referenced <image> element\n                image = contentDocument.querySelector(id).cloneNode(),\n                parent = use.parentNode;\n            // remove the id so we don't have duplicates\n            image.removeAttribute('id');\n            // copy over the transform\n            image.setAttribute('transform', use.getAttribute('transform'));\n            // replace the use with the image\n            parent.replaceChild(image, use);\n        });\n    }\n\n    /**\n     * Embed the SVG into the page\n     * @returns {void}\n     * @private\n     */\n    function embedSVG(svgText) {\n        var domParser,\n            svgDoc,\n            svgEl,\n            html,\n            dataURLPrefix,\n            contentDocument = $svg[0].contentDocument,\n            contentWindow = $svg[0].contentWindow ||\n                             // @NOTE: supports older versions of ff\n                            contentDocument && contentDocument.defaultView;\n\n        switch (embedStrategy) {\n            case EMBED_STRATEGY_IFRAME_INNERHTML:\n                // @NOTE: IE 9 fix. This line in the file is causing the page not to render in IE 9.\n                // The link is not needed here anymore because we are including the stylesheet separately.\n                if (browser.ielt10) {\n                    svgText = svgText.replace(/<xhtml:link.*/,'');\n                }\n                html = HTML_TEMPLATE + svgText;\n                // @NOTE: documentElement.innerHTML is read-only in IE\n                if (browser.ielt10) {\n                    contentDocument.body.innerHTML = html;\n                } else {\n                    contentDocument.documentElement.innerHTML = html;\n                    // @NOTE: there is a bug in Safari 6 where <use>\n                    // elements don't work properly\n                    if ((browser.ios || browser.safari) && browser.version < 7) {\n                        fixUseElements(contentDocument);\n                    }\n                }\n                svgEl = contentDocument.getElementsByTagName('svg')[0];\n                break;\n\n            case EMBED_STRATEGY_IFRAME_PROXY:\n                contentDocument.documentElement.innerHTML = HTML_TEMPLATE;\n                var head = contentDocument.getElementsByTagName('head')[0] || contentDocument.documentElement,\n                    script = contentDocument.createElement('script'),\n                    data = '('+proxySVG+')()'; // IIFE to create window.loadSVG\n                script.type = 'text/javascript';\n                try {\n                    // doesn't work on ie...\n                    script.appendChild(document.createTextNode(data));\n                } catch(e) {\n                    // IE has funky script nodes\n                    script.text = data;\n                }\n                head.insertBefore(script, head.firstChild);\n                if (contentDocument.readyState === 'complete') {\n                    contentWindow.loadSVG(svgText);\n                } else {\n                    contentWindow.onload = function () {\n                        this.loadSVG(svgText);\n                    };\n                }\n                // NOTE: return is necessary here because we are waiting for a callback\n                // before unsetting svgText\n                return;\n\n            case EMBED_STRATEGY_DATA_URL:\n                domParser = new DOMParser();\n                svgDoc = domParser.parseFromString(svgText, SVG_MIME_TYPE);\n                svgEl = contentDocument.importNode(svgDoc.documentElement, true);\n                contentDocument.documentElement.appendChild(svgEl);\n                break;\n\n            case EMBED_STRATEGY_DATA_URL_PROXY:\n                contentWindow.loadSVG(svgText);\n                svgEl = contentDocument.querySelector('svg');\n                break;\n\n            case EMBED_STRATEGY_INLINE_SVG:\n                domParser = new DOMParser();\n                svgDoc = domParser.parseFromString(svgText, SVG_MIME_TYPE);\n                svgEl = document.importNode(svgDoc.documentElement, true);\n                $svg.append(svgEl);\n                break;\n\n            case EMBED_STRATEGY_BASIC_OBJECT:\n                $svg.attr({\n                    type: SVG_MIME_TYPE,\n                    data: scope.getDataProvider('page-svg').getURL(page)\n                });\n                svgEl = $svg[0];\n                break;\n\n            case EMBED_STRATEGY_BASIC_IMG:\n                svgEl = $svg[0];\n                svgEl.src = scope.getDataProvider('page-svg').getURL(page);\n                break;\n\n            case EMBED_STRATEGY_DATA_URL_IMG:\n                svgEl = $svg[0];\n                dataURLPrefix = 'data:' + SVG_MIME_TYPE;\n                if (!browser.ie && window.btoa) {\n                    svgEl.src = dataURLPrefix + ';base64,' + window.btoa(svgText);\n                } else {\n                    svgEl.src = dataURLPrefix + ',' + encodeURIComponent(svgText);\n                }\n                break;\n\n            // no default\n        }\n\n        // make sure the svg width/height are explicity set to 100%\n        svgEl.setAttribute('width', '100%');\n        svgEl.setAttribute('height', '100%');\n    }\n\n    /**\n     * handle SVG load success\n     * @param   {string} text The SVG text\n     * @returns {void}\n     */\n    function loadSVGSuccess(text) {\n        if (!destroyed && !unloaded) {\n            if (!svgLoaded && text) {\n                embedSVG(text);\n                svgLoaded = true;\n                if (!removeOnUnload) {\n                    // cleanup the promise (abort will remove the svg text from\n                    // the in-memory cache as well)\n                    $loadSVGPromise.abort();\n                    $loadSVGPromise = null;\n                }\n            }\n            // always insert the svg el when load was successful\n            if ($svg.parent().length === 0) {\n                $svg.appendTo($svgLayer);\n            }\n        }\n    }\n\n    /**\n     * Handle SVG load failure\n     * @param   {*} error The error\n     * @returns {void}\n     */\n    function loadSVGFail(error) {\n        scope.broadcast('asseterror', error);\n        svgLoaded = false;\n        if ($loadSVGPromise) {\n            $loadSVGPromise.abort();\n        }\n        // don't set the promise to null, because when it fails it should fail\n        // for good...\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n        /**\n         * Initialize the page-svg component\n         * @param {jQuery} $el The element to load SVG layer into\n         * @param  {number} pageNum The page number\n         * @returns {void}\n         */\n        init: function ($el, pageNum) {\n            $svgLayer = $el;\n            page = pageNum;\n            embedStrategy = viewerConfig.embedStrategy || embedStrategy;\n        },\n\n        /**\n         * Destroy the page-svg component\n         * @returns {void}\n         */\n        destroy: function () {\n            destroyed = true;\n            removeOnUnload = true;\n            this.unload();\n            $svgLayer.empty();\n        },\n\n        /**\n         * Prepare the element for loading\n         * @returns {void}\n         */\n        prepare: function () {\n            prepareSVGContainer();\n        },\n\n        /**\n         * Prepare the SVG object to be loaded and start loading SVG text\n         * @returns {void}\n         */\n        preload: function () {\n            this.prepare();\n\n            if (!$loadSVGPromise) {\n                $loadSVGPromise = loadSVGText();\n            }\n        },\n\n        /**\n         * Load the SVG and call callback when complete.\n         * If there was an error, callback's first argument will be\n         * an error message, and falsy otherwise.\n         * @returns {$.Promise}    A jQuery promise object\n         */\n        load: function () {\n            unloaded = false;\n            this.preload();\n            $loadSVGPromise\n                .done(loadSVGSuccess)\n                .fail(loadSVGFail);\n            return $loadSVGPromise;\n        },\n\n        /**\n         * Unload the SVG object if necessary\n         * @returns {void}\n         */\n        unload: function () {\n            unloaded = true;\n            // stop loading the page if it hasn't finished yet\n            if ($loadSVGPromise && $loadSVGPromise.state() !== 'resolved') {\n                $loadSVGPromise.abort();\n                $loadSVGPromise = null;\n            }\n\n            // remove the svg element if necessary\n            if (removeOnUnload) {\n                if ($svg) {\n                    $svg.remove();\n                    $svg = null;\n                }\n                svgLoaded = false;\n            }\n        }\n    };\n});\n\n/**\n * page-text component\n */\nCrocodoc.addComponent('page-text', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var browser = scope.getUtility('browser'),\n        subpx   = scope.getUtility('subpx');\n\n    var destroyed = false,\n        loaded = false,\n        $textLayer,\n        $loadTextPromise,\n        page,\n        viewerConfig = scope.getConfig();\n\n    /**\n     * Return true if we should use the text layer, false otherwise\n     * @returns {bool}\n     * @private\n     */\n    function shouldUseTextLayer() {\n        return viewerConfig.enableTextSelection && !browser.ielt9;\n    }\n\n    /**\n     * Handle success loading HTML text\n     * @param {string} text The HTML text\n     * @returns {void}\n     * @private\n     */\n    function loadTextLayerHTMLSuccess(text) {\n        var doc, textEl;\n\n        if (!text || loaded || destroyed) {\n            return;\n        }\n\n        loaded = true;\n\n        // create a document to parse the html text\n        doc = document.implementation.createHTMLDocument('');\n        doc.getElementsByTagName('body')[0].innerHTML = text;\n        text = null;\n\n        // select just the element we want (CSS_CLASS_PAGE_TEXT)\n        textEl = document.importNode(doc.querySelector('.' + CSS_CLASS_PAGE_TEXT), true);\n        $textLayer.attr('class', textEl.getAttribute('class'));\n        $textLayer.html(textEl.innerHTML);\n        subpx.fix($textLayer);\n    }\n\n    function loadTextLayerHTMLFail(error) {\n        if (error) {\n            scope.broadcast('asseterror', error);\n        }\n    }\n\n    /**\n     * Load text html if necessary and insert it into the element\n     * @returns {$.Promise}\n     * @private\n     */\n    function loadTextLayerHTML() {\n        // already load(ed|ing)?\n        if (!$loadTextPromise) {\n            if (shouldUseTextLayer()) {\n                $loadTextPromise = scope.get('page-text', page);\n            } else {\n                $loadTextPromise = $.Deferred().resolve().promise({\n                    abort: function () {}\n                });\n            }\n        }\n\n        return $loadTextPromise;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        /**\n         * Initialize the page-text component\n         * @param {jQuery} $el The jQuery element to load the text layer into\n         * @returns {void}\n         */\n        init: function ($el, pageNum) {\n            $textLayer = $el;\n            page = pageNum;\n        },\n\n        /**\n         * Destroy the page-text component\n         * @returns {void}\n         */\n        destroy: function () {\n            destroyed = true;\n            this.unload();\n            $textLayer.empty();\n        },\n\n        /**\n         * Start loading HTML text\n         * @returns {void}\n         */\n        preload: function () {\n            loadTextLayerHTML();\n        },\n\n        /**\n         * Load the html text for the text layer and insert it into the element\n         * if text layer is enabled and is not loading/has not already been loaded\n         * @returns {$.Promise} A promise to load the text layer\n         */\n        load: function () {\n            return loadTextLayerHTML()\n                .done(loadTextLayerHTMLSuccess)\n                .fail(loadTextLayerHTMLFail);\n        },\n\n        /**\n         * Stop loading the text layer (no need to actually remove it)\n         * @returns {void}\n         */\n        unload: function () {\n            if ($loadTextPromise && $loadTextPromise.state() !== 'resolved') {\n                $loadTextPromise.abort();\n                $loadTextPromise = null;\n            }\n        },\n\n        /**\n         * Enable text selection\n         * @returns {void}\n         */\n        enable: function () {\n            $textLayer.css('display', '');\n            // we created an empty promise if text selection was previously disabled,\n            // so we can scrap it so a new promise will be created next time this\n            // page is requested\n            if ($loadTextPromise && !loaded) {\n                $loadTextPromise = null;\n            }\n        },\n\n        /**\n         * Disable text selection\n         * @returns {void}\n         */\n        disable: function () {\n            $textLayer.css('display', 'none');\n        }\n    };\n});\n\n/**\n * Page component\n */\nCrocodoc.addComponent('page', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var support = scope.getUtility('support'),\n        util = scope.getUtility('common');\n\n    var $el,\n        pageText, pageContent, pageLinks,\n        pageNum, index,\n        isVisible, status,\n        loadRequested = false;\n\n    return {\n        messages: [\n            'pageavailable',\n            'pagefocus',\n            'textenabledchange',\n            'zoom'\n        ],\n\n        /**\n         * Handle framework messages\n         * @param {string} name The name of the message\n         * @param {Object} data The related data for the message\n         * @returns {void}\n         */\n        onmessage: function (name, data) {\n            switch (name) {\n                case 'pageavailable':\n                    if (data.page === index + 1 || data.upto > index || data.all === true) {\n                        if (status === PAGE_STATUS_CONVERTING) {\n                            status = PAGE_STATUS_NOT_LOADED;\n                        }\n                    }\n                    break;\n                case 'textenabledchange':\n                    if (data.enabled === true) {\n                        this.enableTextSelection();\n                    } else {\n                        this.disableTextSelection();\n                    }\n                    break;\n                case 'pagefocus':\n                    // falls through\n                case 'zoom':\n                    isVisible = pageNum === data.page || (util.inArray(pageNum, data.visiblePages) > -1);\n                    break;\n\n                // no default\n            }\n        },\n\n        /**\n         * Initialize the Page component\n         * @returns {void}\n         */\n        init: function ($pageEl, config) {\n            var $text, $svg, $links;\n            $el = $pageEl;\n            $svg = $pageEl.find('.' + CSS_CLASS_PAGE_SVG);\n            $text = $pageEl.find('.' + CSS_CLASS_PAGE_TEXT);\n            $links = $pageEl.find('.' + CSS_CLASS_PAGE_LINKS);\n\n            status = config.status || PAGE_STATUS_NOT_LOADED;\n            index = config.index;\n            pageNum = index + 1;\n            this.config = config;\n\n            config.url = config.url || '';\n            pageText = scope.createComponent('page-text');\n            pageContent = support.svg ?\n                    scope.createComponent('page-svg') :\n                    scope.createComponent('page-img');\n\n            pageText.init($text, pageNum);\n            pageContent.init($svg, pageNum);\n\n            if (config.enableLinks && config.links.length) {\n                pageLinks = scope.createComponent('page-links');\n                pageLinks.init($links, config.links);\n            }\n        },\n\n        /**\n         * Destroy the page component\n         * @returns {void}\n         */\n        destroy: function () {\n            this.unload();\n        },\n\n        /**\n         * Preload the SVG if the page is not loaded\n         * @returns {void}\n         */\n        preload: function () {\n            pageContent.prepare();\n            if (status === PAGE_STATUS_NOT_LOADED) {\n                pageContent.preload();\n                pageText.preload();\n            }\n        },\n\n        /**\n         * Load and show SVG and text assets for this page\n         * @returns {$.Promise}    jQuery Promise object or false if the page is not loading\n         */\n        load: function () {\n            var pageComponent = this;\n\n            loadRequested = true;\n\n            // the page has failed to load for good... don't try anymore\n            if (status === PAGE_STATUS_ERROR) {\n                return false;\n            }\n\n            // don't actually load if the page is converting\n            if (status === PAGE_STATUS_CONVERTING) {\n                return false;\n            }\n\n            // request assets to be loaded... but only ACTUALLY load if it is\n            // not loaded already\n            if (status !== PAGE_STATUS_LOADED) {\n                status = PAGE_STATUS_LOADING;\n            }\n            return $.when(pageContent.load(), pageText.load())\n                .done(function handleLoadDone() {\n                    if (loadRequested) {\n                        if (status !== PAGE_STATUS_LOADED) {\n                            $el.removeClass(CSS_CLASS_PAGE_LOADING);\n                            status = PAGE_STATUS_LOADED;\n                            scope.broadcast('pageload', { page: pageNum });\n                        }\n                    } else {\n                        pageComponent.unload();\n                    }\n                })\n                .fail(function handleLoadFail(error) {\n                    status = PAGE_STATUS_ERROR;\n                    $el.addClass(CSS_CLASS_PAGE_ERROR);\n                    scope.broadcast('pagefail', { page: index + 1, error: error });\n                });\n        },\n\n        /**\n         * Unload/hide SVG and text assets for this page\n         * @returns {void}\n         */\n        unload: function () {\n            loadRequested = false;\n            pageContent.unload();\n            pageText.unload();\n            if (status === PAGE_STATUS_LOADED) {\n                status = PAGE_STATUS_NOT_LOADED;\n                $el.addClass(CSS_CLASS_PAGE_LOADING);\n                $el.removeClass(CSS_CLASS_PAGE_ERROR);\n                scope.broadcast('pageunload', { page: pageNum });\n            }\n        },\n\n        /**\n         * Enable text selection, loading text assets if the page is visible\n         * @returns {void}\n         */\n        enableTextSelection: function () {\n            pageText.enable();\n            if (isVisible) {\n                pageText.load();\n            }\n        },\n\n        /**\n         * Disable text selection\n         * @returns {void}\n         */\n        disableTextSelection: function () {\n            pageText.disable();\n        }\n    };\n});\n\n\n\n/**\n * resizer component definition\n */\nCrocodoc.addComponent('resizer', function (scope) {\n\n    'use strict';\n\n    var util = scope.getUtility('common');\n\n    // shorter way of defining\n    // 'fullscreenchange webkitfullscreenchange mozfullscreenchange MSFullscreenChange'\n    var FULLSCREENCHANGE_EVENT = ['', ' webkit', ' moz', ' ']\n        .join('fullscreenchange') +\n        // @NOTE: IE 11 uses upper-camel-case for this, which is apparently necessary\n        'MSFullscreenChange';\n\n    var $window = $(window),\n        $document = $(document),\n        element,\n        frameWidth = 0,\n        currentClientWidth,\n        currentClientHeight,\n        currentOffsetWidth,\n        currentOffsetHeight,\n        inIframe = (function () {\n            try {\n                return window.self !== window.top;\n            } catch (e) {\n                return true;\n            }\n        })();\n\n    /**\n     * Fire the resize event with the proper data\n     * @returns {void}\n     * @private\n     */\n    function broadcast() {\n        scope.broadcast('resize', {\n            // shortcuts for offsetWidth/height\n            width: currentOffsetWidth,\n            height: currentOffsetHeight,\n            // client width is width of the inner, visible area\n            clientWidth: currentClientWidth,\n            clientHeight: currentClientHeight,\n            // offset width is the width of the element, including border,\n            // padding, and scrollbars\n            offsetWidth: currentOffsetWidth,\n            offsetHeight: currentOffsetHeight\n        });\n    }\n\n    /**\n     * Initialize an iframe to fire events on resize\n     * @returns {void}\n     * @private\n     */\n    function initResizer() {\n        var $iframe = $('<iframe frameborder=\"0\">'),\n            $div = $('<div>');\n        $iframe.add($div).css({\n            opacity: 0,\n            visiblility: 'hidden',\n            position: 'absolute',\n            width: '100%',\n            height: '100%',\n            top: 0,\n            left: 0,\n            border: 0\n        });\n        $iframe.prependTo($div.prependTo(element));\n        if (util.getComputedStyle(element).position === 'static') {\n            $(element).css({ position: 'relative' });\n        }\n        $window = $($iframe[0].contentWindow);\n        $window.on('resize', checkResize);\n    }\n\n    /**\n     * Check if the element has resized, and broadcast the resize event if so\n     * @returns {void}\n     * @private\n     */\n    function checkResize() {\n        var newOffsetHeight = element.offsetHeight,\n            newOffsetWidth = element.offsetWidth;\n\n        // check if we're in a frame\n        if (inIframe) {\n            // firefox has an issue where styles aren't calculated in hidden iframes\n            // if the iframe was hidden and is now visible, broadcast a\n            // layoutchange event\n            if (frameWidth === 0 && window.innerWidth !== 0) {\n                frameWidth = window.innerWidth;\n                scope.broadcast('layoutchange');\n                return;\n            }\n        }\n\n        //on touch devices, the offset height is sometimes zero as content is loaded\n        if (newOffsetHeight) {\n            if (newOffsetHeight !== currentOffsetHeight || newOffsetWidth !== currentOffsetWidth) {\n                currentOffsetHeight = newOffsetHeight;\n                currentOffsetWidth = newOffsetWidth;\n                currentClientHeight = element.clientHeight;\n                currentClientWidth = element.clientWidth;\n                broadcast();\n            }\n        }\n    }\n\n    return {\n\n        messages: [\n            'layoutchange'\n        ],\n\n        /**\n         * Handle framework messages\n         * @returns {void}\n         */\n        onmessage: function () {\n            // force trigger resize when layout changes\n            // @NOTE: we do this because the clientWidth/Height\n            // could be different based on the layout (and whether\n            // or not the new layout changes scrollbars)\n            currentOffsetHeight = null;\n            checkResize();\n        },\n\n        /**\n         * Initialize the Resizer component with an element to watch\n         * @param  {HTMLElement} el The element to watch\n         * @returns {void}\n         */\n        init: function (el) {\n            element = $(el).get(0);\n\n            // use the documentElement for viewport dimensions\n            // if we are using the window as the viewport\n            if (element === window) {\n                element = document.documentElement;\n                $window.on('resize', checkResize);\n            } else {\n                initResizer();\n            }\n\n           $document.on(FULLSCREENCHANGE_EVENT, checkResize);\n\n            checkResize();\n        },\n\n        /**\n         * Destroy the Resizer component\n         * @returns {void}\n         */\n        destroy: function () {\n            $document.off(FULLSCREENCHANGE_EVENT, checkResize);\n            $window.off('resize', checkResize);\n        }\n    };\n});\n\n/*global setTimeout, clearTimeout */\n\nCrocodoc.addComponent('scroller', function (scope) {\n\n    'use strict';\n\n    var util = scope.getUtility('common'),\n        browser = scope.getUtility('browser');\n\n    var GHOST_SCROLL_TIMEOUT = 3000,\n        GHOST_SCROLL_INTERVAL = 30,\n        SCROLL_EVENT_THROTTLE_INTERVAL = 200,\n        SCROLL_END_TIMEOUT = browser.mobile ? 500 : 250;\n\n    var $el,\n        scrollendTID,\n        scrollingStarted = false,\n        touchStarted = false,\n        touchEnded = false,\n        touchMoved = false,\n        touchEndTime = 0,\n        ghostScrollStart = null;\n\n    /**\n     * Build event data object for firing scroll events\n     * @returns {Object} Scroll event data object\n     * @private\n     */\n    function buildEventData() {\n        return {\n            scrollTop: $el.scrollTop(),\n            scrollLeft: $el.scrollLeft()\n        };\n    }\n\n    /**\n     * Broadcast a scroll event\n     * @returns {void}\n     * @private\n     */\n    var fireScroll = util.throttle(SCROLL_EVENT_THROTTLE_INTERVAL, function () {\n        scope.broadcast('scroll', buildEventData());\n    });\n\n    /**\n     * Handle scrollend\n     * @returns {void}\n     * @private\n     */\n    function handleScrollEnd() {\n        scrollingStarted = false;\n        ghostScrollStart = null;\n        clearTimeout(scrollendTID);\n        scope.broadcast('scrollend', buildEventData());\n    }\n\n    /**\n     * Handle scroll events\n     * @returns {void}\n     * @private\n     */\n    function handleScroll() {\n        // if we are just starting scrolling, fire scrollstart event\n        if (!scrollingStarted) {\n            scrollingStarted = true;\n            scope.broadcast('scrollstart', buildEventData());\n        }\n        clearTimeout(scrollendTID);\n        scrollendTID = setTimeout(handleScrollEnd, SCROLL_END_TIMEOUT);\n        fireScroll();\n    }\n\n    /**\n     * Handle touch start events\n     * @returns {void}\n     * @private\n     */\n    function handleTouchstart() {\n        touchStarted = true;\n        touchEnded = false;\n        touchMoved = false;\n        handleScroll();\n    }\n\n    /**\n     * Handle touchmove events\n     * @returns {void}\n     * @private\n     */\n    function handleTouchmove() {\n        touchMoved = true;\n        handleScroll();\n    }\n\n    /**\n     * Handle touchend events\n     * @returns {void}\n     * @private\n     */\n    function handleTouchend() {\n        touchStarted = false;\n        touchEnded = true;\n        touchEndTime = new Date().getTime();\n        if (touchMoved) {\n            ghostScroll();\n        }\n    }\n\n    /**\n     * Fire fake scroll events.\n     * iOS doesn't fire events during the 'momentum' part of scrolling\n     * so this is used to fake these events until the page stops moving.\n     * @returns {void}\n     * @private\n     */\n    function ghostScroll() {\n        clearTimeout(scrollendTID);\n        if (ghostScrollStart === null) {\n            ghostScrollStart = new Date().getTime();\n        }\n        if (new Date().getTime() - ghostScrollStart > GHOST_SCROLL_TIMEOUT) {\n            handleScrollEnd();\n            return;\n        }\n        fireScroll();\n        scrollendTID = setTimeout(ghostScroll, GHOST_SCROLL_INTERVAL);\n    }\n\n    return {\n        /**\n         * Initialize the scroller component\n         * @param   {Element} el The Element\n         * @returns {void}\n         */\n        init: function (el) {\n            $el = $(el);\n            $el.on('scroll', handleScroll);\n            $el.on('touchstart', handleTouchstart);\n            $el.on('touchmove', handleTouchmove);\n            $el.on('touchend', handleTouchend);\n        },\n\n        /**\n         * Destroy the scroller component\n         * @returns {void}\n         */\n        destroy: function () {\n            clearTimeout(scrollendTID);\n            $el.off('scroll', handleScroll);\n            $el.off('touchstart', handleTouchstart);\n            $el.off('touchmove', handleTouchmove);\n            $el.off('touchend', handleTouchend);\n        }\n    };\n});\n\nCrocodoc.addComponent('viewer-base', function (scope) {\n\n    'use strict';\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    var util = scope.getUtility('common'),\n        browser = scope.getUtility('browser'),\n        support = scope.getUtility('support');\n\n    var api, // the viewer API object\n        config,\n        $el,\n        stylesheetEl,\n        layout,\n        scroller,\n        resizer,\n        dragger,\n        $assetsPromise;\n\n    /**\n     * Add CSS classes to the element for necessary feature/support flags\n     * @returns {void}\n     * @private\n     */\n    function setCSSFlags() {\n        // add SVG version number flag\n        $el.attr(ATTR_SVG_VERSION, config.metadata.version || '0.0.0');\n\n        //add CSS flags\n        if (browser.mobile) {\n            $el.addClass(CSS_CLASS_MOBILE);      //Mobile?\n        }\n        if (browser.ielt9) {\n            $el.addClass(CSS_CLASS_IELT9);       //IE7 or IE8?\n        }\n        if (support.svg) {\n            $el.addClass(CSS_CLASS_SUPPORTS_SVG);\n        }\n    }\n\n    /**\n     * Create and insert basic viewer DOM structure\n     * @returns {void}\n     * @private\n     */\n    function initViewerHTML() {\n        // create viewer HTML\n        $el.html(Crocodoc.viewerTemplate);\n        if (config.useWindowAsViewport) {\n            config.$viewport = $(window);\n            $el.addClass(CSS_CLASS_WINDOW_AS_VIEWPORT);\n        } else {\n            config.$viewport = $el.find('.' + CSS_CLASS_VIEWPORT);\n        }\n        config.$doc = $el.find('.' + CSS_CLASS_DOC);\n    }\n\n    /**\n     * Initialize all plugins specified for this viewer instance\n     * @returns {void}\n     * @private\n     */\n    function initPlugins() {\n        var name,\n            plugin,\n            plugins = config.plugins || {};\n        for (name in plugins) {\n            plugin = scope.createComponent('plugin-' + name);\n            if (plugin && util.isFn(plugin.init)) {\n                plugin.init(config.plugins[name]);\n            }\n        }\n    }\n\n    /**\n     * Complete intialization after document metadata has been loaded;\n     * ie., bind events, init lazyloader and layout, broadcast ready message\n     * @returns {void}\n     * @private\n     */\n    function completeInit() {\n        setCSSFlags();\n\n        // initialize scroller and resizer components\n        scroller = scope.createComponent('scroller');\n        scroller.init(config.$viewport);\n        resizer = scope.createComponent('resizer');\n        resizer.init(config.$viewport);\n\n        var controller;\n        switch (config.metadata.type) {\n            case 'text':\n                // load text-based viewer\n                controller = scope.createComponent('controller-text');\n                // force the text layout only\n                // @TODO: allow overriding the layout eventually\n                config.layout = LAYOUT_TEXT;\n                break;\n\n            case 'paged':\n                /* falls through */\n            default:\n                controller = scope.createComponent('controller-paged');\n                break;\n        }\n        controller.init();\n\n        // disable text selection if necessary\n        if (config.metadata.type === 'text') {\n            if (!config.enableTextSelection) {\n                api.disableTextSelection();\n            }\n        } else if (browser.ielt9) {\n            api.disableTextSelection();\n        }\n\n        // disable links if necessary\n        // @NOTE: links are disabled in IE < 9\n        if (!config.enableLinks || browser.ielt9) {\n            api.disableLinks();\n        }\n\n        // set the initial layout\n        api.setLayout(config.layout);\n\n        // broadcast ready message\n        scope.broadcast('ready', {\n            page: config.page || 1,\n            numPages: config.numPages\n        });\n\n        scope.ready();\n    }\n\n    /**\n     * Handler for linkclick messages\n     * @returns {void}\n     * @private\n     */\n    function handleLinkClick(data) {\n        var event = api.fire('linkclick', data);\n        if (!event.isDefaultPrevented()) {\n            if (data.uri) {\n                window.open(data.uri);\n            } else if (data.destination) {\n                api.scrollTo(data.destination.pagenum);\n            }\n        }\n    }\n\n    /**\n     * Enable or disable the dragger given the `isDraggable` flag\n     * @param   {Boolean} isDraggable Whether or not the layout is draggable\n     * @returns {void}\n     * @private\n     */\n    function updateDragger(isDraggable) {\n        if (isDraggable) {\n            if (!dragger) {\n                $el.addClass(CSS_CLASS_DRAGGABLE);\n                dragger = scope.createComponent('dragger');\n                dragger.init(config.$viewport);\n            }\n        } else {\n            if (dragger) {\n                $el.removeClass(CSS_CLASS_DRAGGABLE);\n                scope.destroyComponent(dragger);\n                dragger = null;\n            }\n        }\n    }\n\n    /**\n     * Validates and normalizes queryParams config option\n     * @returns {void}\n     */\n    function validateQueryParams() {\n        var queryString;\n        if (config.queryParams) {\n            if (typeof config.queryParams === 'string') {\n                // strip '?' if it's there, because we add it below\n                queryString = config.queryParams.replace(/^\\?/, '');\n            } else {\n                queryString = util.param(config.queryParams);\n            }\n        }\n        config.queryString = queryString ? '?' + queryString : '';\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n\n        messages: [\n            'asseterror',\n            'destroy',\n            'dragend',\n            'dragstart',\n            'fail',\n            'layoutchange',\n            'linkclick',\n            'pagefail',\n            'pagefocus',\n            'pageload',\n            'pageunload',\n            'ready',\n            'resize',\n            'scrollstart',\n            'scrollend',\n            'zoom'\n        ],\n\n        /**\n         * Handle framework messages\n         * @param {string} name The name of the message\n         * @param {any} data The related data for the message\n         * @returns {void}\n         */\n        onmessage: function (name, data) {\n            switch (name) {\n                case 'layoutchange':\n                    api.updateLayout();\n                    break;\n\n                case 'linkclick':\n                    handleLinkClick(data);\n                    break;\n\n                case 'zoom':\n                    // artificially adjust the reported zoom to be accuate given the page scale\n                    data.zoom *= config.pageScale;\n                    data.prevZoom *= config.pageScale;\n                    if (config.enableDragging) {\n                        updateDragger(data.isDraggable);\n                    }\n\n                    // forward zoom event to external event handlers\n                    api.fire(name, data);\n                    break;\n\n                case 'dragstart':\n                    if (!$el.hasClass(CSS_CLASS_DRAGGING)) {\n                        $el.addClass(CSS_CLASS_DRAGGING);\n                    }\n                    // forward zoom event to external event handlers\n                    api.fire(name, data);\n                    break;\n\n                case 'dragend':\n                    if ($el.hasClass(CSS_CLASS_DRAGGING)) {\n                        $el.removeClass(CSS_CLASS_DRAGGING);\n                    }\n                    // forward zoom event to external event handlers\n                    api.fire(name, data);\n                    break;\n\n                default:\n                    // forward subscribed framework messages to external event handlers\n                    api.fire(name, data);\n                    break;\n            }\n        },\n\n        /**\n         * Initialize the viewer api\n         * @returns {void}\n         */\n        init: function () {\n            config = scope.getConfig();\n            api = config.api;\n\n            // create a unique CSS namespace for this viewer instance\n            config.namespace = CSS_CLASS_VIEWER + '-' + config.id;\n\n            // Setup container\n            $el = config.$el;\n\n            // add crocodoc viewer and namespace classes\n            $el.addClass(CSS_CLASS_VIEWER);\n            $el.addClass(config.namespace);\n\n            // add a / to the end of the base url if necessary\n            if (config.url) {\n                if (!/\\/$/.test(config.url)) {\n                    config.url += '/';\n                }\n            } else {\n                throw new Error('no URL given for viewer assets');\n            }\n\n            // make the url absolute\n            config.url = scope.getUtility('url').makeAbsolute(config.url);\n\n            validateQueryParams();\n            initViewerHTML();\n            initPlugins();\n        },\n\n        /**\n         * Destroy the viewer-base component\n         * @returns {void}\n         */\n        destroy: function () {\n            // empty container and remove all class names that contain \"crocodoc\"\n            $el.empty().removeClass(function (i, cls) {\n                var match = cls.match(new RegExp('crocodoc\\\\S+', 'g'));\n                return match && match.join(' ');\n            });\n\n            // remove the stylesheet\n            $(stylesheetEl).remove();\n\n            if ($assetsPromise) {\n                $assetsPromise.abort();\n            }\n        },\n\n        /**\n         * Set the layout to the given mode, destroying and cleaning up the current\n         * layout if there is one\n         * @param  {string} layoutMode The layout mode\n         * @returns {Layout} The layout object\n         */\n        setLayout: function (layoutMode) {\n            // create a layout component with the new layout config\n            var lastPage = config.page,\n                lastZoom = config.zoom || 1,\n                previousLayoutMode = config.layout,\n                newLayout;\n\n            // if there is already a layout, save some state\n            if (layout) {\n                // ignore this if we already have the specified layout\n                if (layoutMode === previousLayoutMode) {\n                    return layout;\n                }\n\n                lastPage = layout.state.currentPage;\n                lastZoom = layout.state.zoomState;\n            }\n\n            newLayout = scope.createComponent('layout-' + layoutMode);\n            if (!newLayout) {\n                throw new Error('Invalid layout ' +  layoutMode);\n            }\n\n            // remove and destroy the existing layout component\n            // @NOTE: this must be done after we decide if the\n            // new layout exists!\n            if (layout) {\n                scope.destroyComponent(layout);\n            }\n\n            config.layout = layoutMode;\n\n            layout = newLayout;\n            layout.init();\n            layout.setZoom(lastZoom.zoomMode || lastZoom.zoom || lastZoom);\n            if (util.isFn(layout.scrollTo)) {\n                layout.scrollTo(lastPage);\n            }\n            config.currentLayout = layout;\n\n            scope.broadcast('layoutchange', {\n                // in the context of event data, `layout` and `previousLayout`\n                // are actually the name of those layouts, and not the layout\n                // objects themselves\n                previousLayout: previousLayoutMode,\n                layout: layoutMode\n            });\n            return layout;\n        },\n\n        /**\n         * Load the metadata and css for this document\n         * @returns {void}\n         */\n        loadAssets: function () {\n            var $loadStylesheetPromise,\n                $loadMetadataPromise,\n                $pageOneContentPromise,\n                $pageOneTextPromise;\n\n            if ($assetsPromise) {\n                return;\n            }\n\n            $loadMetadataPromise = scope.get('metadata');\n            $loadMetadataPromise.then(function handleMetadataResponse(metadata) {\n                config.metadata = metadata;\n            });\n\n            // don't load the stylesheet for IE < 9\n            if (browser.ielt9) {\n                stylesheetEl = util.insertCSS('');\n                config.stylesheet = stylesheetEl.styleSheet;\n                $loadStylesheetPromise = $.when('').promise({\n                    abort: function () {}\n                });\n            } else {\n                $loadStylesheetPromise = scope.get('stylesheet');\n                $loadStylesheetPromise.then(function handleStylesheetResponse(cssText) {\n                    stylesheetEl = util.insertCSS(cssText);\n                    config.stylesheet = stylesheetEl.sheet;\n                });\n            }\n\n\n            // load page 1 assets immediately if necessary\n            if (config.autoloadFirstPage &&\n                (!config.pageStart || config.pageStart === 1)) {\n                if (support.svg) {\n                    $pageOneContentPromise = scope.get('page-svg', 1);\n                } else if (config.conversionIsComplete) {\n                    // unfortunately, page-1.png is not necessarily available\n                    // on View API's document.viewable event, so we can only\n                    // prefetch page-1.png if conversion is complete\n                    $pageOneContentPromise = scope.get('page-img', 1);\n                }\n                if (config.enableTextSelection) {\n                    $pageOneTextPromise = scope.get('page-text', 1);\n                }\n            }\n\n            // when both metatadata and stylesheet are done or if either fails...\n            $assetsPromise = $.when($loadMetadataPromise, $loadStylesheetPromise)\n                .fail(function (error) {\n                    if ($assetsPromise) {\n                        $assetsPromise.abort();\n                    }\n                    scope.ready();\n                    scope.broadcast('asseterror', error);\n                    scope.broadcast('fail', error);\n                })\n                .then(completeInit)\n                .promise({\n                    abort: function () {\n                        $assetsPromise = null;\n                        $loadMetadataPromise.abort();\n                        $loadStylesheetPromise.abort();\n                        if ($pageOneContentPromise) {\n                            $pageOneContentPromise.abort();\n                        }\n                        if ($pageOneTextPromise) {\n                            $pageOneTextPromise.abort();\n                        }\n                    }\n                });\n        }\n    };\n});\n\n\n        return Crocodoc;\n    }));\n})(typeof window !== 'undefined' ? window : this);\n"],"sourceRoot":"/source/"}