{"version":3,"file":"ThumbnailImage.js","sources":["../../src/icons/ImageIcon.vue","../../src/components/LazyLoadImage/getScrollParent.ts","../../src/components/LazyLoadImage/LazyLoadImage.vue","../../src/icons/ArrowForwardIcon.vue"],"sourcesContent":["<template>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    stroke-width=\"1.5\"\n    stroke=\"currentColor\"\n    class=\"w-5 h-5\"\n  >\n    <path\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n      d=\"M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z\"\n    />\n  </svg>\n</template>\n<script setup lang=\"ts\"></script>\n<style scoped></style>\n","/**\n * gets the scroll parent of the given element\n * based on this discussion:\n * https://stackoverflow.com/questions/35939886/find-first-scrollable-parent\n */\n\nexport function isScrollable(node) {\n  const { overflowY, overflowX } = getComputedStyle(node);\n  return (\n    !overflowY.includes(\"hidden\") &&\n    !overflowY.includes(\"visible\") &&\n    !overflowX.includes(\"hidden\") &&\n    !overflowX.includes(\"visible\") &&\n    node.scrollHeight >= node.clientHeight\n  );\n}\n\nexport default function getScrollParent(node: HTMLElement | null): HTMLElement {\n  if (!node) return document.body;\n\n  return isScrollable(node)\n    ? node\n    : getScrollParent(node.parentNode as HTMLElement);\n}\n","<template>\n  <div\n    ref=\"imgContainer\"\n    class=\"lazy-load-image relative w-full h-full min-w-[4rem] min-h-[4rem]\"\n  >\n    <img\n      v-if=\"isLoaded\"\n      class=\"lazy-load-image__image block bg-neutral-100 opacity-0 transition-opacity\"\n      :class=\"{\n        'opacity-100': isImageLoadComplete,\n      }\"\n      :src=\"src\"\n      :alt=\"alt\"\n      v-bind=\"$attrs\"\n      @load=\"isImageLoadComplete = true\"\n    />\n    <div\n      v-if=\"!isImageLoadComplete\"\n      class=\"absolute inset-0 z-10 flex justify-center items-center bg-neutral-200 border border-neutral-300 text-neutral-400\"\n    >\n      <ImageIcon />\n    </div>\n  </div>\n</template>\n<script setup lang=\"ts\">\nimport { useIntersectionObserver } from \"@vueuse/core\";\nimport { ref, onMounted } from \"vue\";\nimport ImageIcon from \"@/icons/ImageIcon.vue\";\nimport getScrollParent from \"./getScrollParent\";\n\ndefineProps<{\n  src: string;\n  alt: string;\n}>();\n\nconst imgContainer = ref<HTMLDivElement | null>(null);\nconst isLoaded = ref(false);\nconst isImageLoadComplete = ref(false);\n\nfunction onIntersectionChange(\n  entries: IntersectionObserverEntry[],\n  observer: IntersectionObserver\n) {\n  entries.forEach((entry) => {\n    if (entry.isIntersecting) {\n      isLoaded.value = true;\n      observer.unobserve(entry.target);\n    }\n  });\n}\n\nonMounted(() => {\n  const observerOptions = {\n    // root needs to be a scrollable element\n    // if the document body isn't scrollable, then rootMargin won't work\n    root: getScrollParent(imgContainer.value),\n\n    // load images when they are `rootMargin` pixels away from the viewport\n    rootMargin: \"640px\",\n\n    // load images when they are `threshold` within the viewport\n    // (0 when just a tiny tiny bit, 1 when 100%)\n    threshold: 0,\n  };\n  useIntersectionObserver(imgContainer, onIntersectionChange, observerOptions);\n});\n</script>\n<style scoped></style>\n","<template>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    stroke-width=\"1.5\"\n    stroke=\"currentColor\"\n    class=\"w-5 h-5\"\n  >\n    <path\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n      d=\"M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3\"\n    />\n  </svg>\n</template>\n<script setup lang=\"ts\"></script>\n<style scoped></style>\n"],"names":["_hoisted_1","_hoisted_2","_createElementVNode","_hoisted_3","_sfc_render","_ctx","_cache","isScrollable","node","overflowY","overflowX","getScrollParent","imgContainer","ref","isLoaded","isImageLoadComplete","onIntersectionChange","entries","observer","entry","onMounted","observerOptions","useIntersectionObserver"],"mappings":"uNAEIA,EAAkC,CAClC,MAAW,6BACX,KAAA,OACA,QAAA,YACA,eAAqB,MACrB,OAAe,gCAGbC,EAAsBC,EAAA,OAAA,CACtB,yBACA,kBAA6S,gUAC7SC,EAAA,IAZJ,SAAAC,EAAAC,EAAAC,EAAA,qDCKK,SAASC,EAAaC,EAAM,CACjC,KAAM,CAAE,UAAAC,EAAW,UAAAC,CAAU,EAAI,iBAAiBF,CAAI,EAEpD,MAAA,CAACC,EAAU,SAAS,QAAQ,GAC5B,CAACA,EAAU,SAAS,SAAS,GAC7B,CAACC,EAAU,SAAS,QAAQ,GAC5B,CAACA,EAAU,SAAS,SAAS,GAC7BF,EAAK,cAAgBA,EAAK,YAE9B,CAEA,SAAwBG,EAAgBH,EAAuC,CAC7E,OAAKA,EAEED,EAAaC,CAAI,EACpBA,EACAG,EAAgBH,EAAK,UAAyB,EAJhC,SAAS,IAK7B,yNCYM,MAAAI,EAAeC,EAA2B,IAAI,EAC9CC,EAAWD,EAAI,EAAK,EACpBE,EAAsBF,EAAI,EAAK,EAE5B,SAAAG,EACPC,EACAC,EACA,CACQD,EAAA,QAASE,GAAU,CACrBA,EAAM,iBACRL,EAAS,MAAQ,GACRI,EAAA,UAAUC,EAAM,MAAM,EACjC,CACD,CACH,CAEA,OAAAC,EAAU,IAAM,CACd,MAAMC,EAAkB,CAGtB,KAAMV,EAAgBC,EAAa,KAAK,EAGxC,WAAY,QAIZ,UAAW,CAAA,EAEWU,EAAAV,EAAcI,EAAsBK,CAAe,CAAA,CAC5E,wZC/DGrB,EAAkC,CAClC,MAAW,6BACX,KAAA,OACA,QAAA,YACA,eAAqB,MACrB,OAAe,gCAGbC,EAAsBC,EAAA,OAAA,CACtB,yBACA,kBAAwC,2DACxCC,EAAA,IAZJ,SAAAC,EAAAC,EAAAC,EAAA"}