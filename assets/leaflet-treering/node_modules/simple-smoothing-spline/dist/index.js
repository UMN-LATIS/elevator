import { matrix, transpose, identity, multiply, add, inv, } from "mathjs";
class InvalidLambdaError extends Error {
}
const pos = (val) => Math.max(val, 0);
const getAllXs = (pts) => pts.map((pt) => pt.x);
const getAllYs = (pts) => pts.map((pt) => pt.y);
function createBasisMatrix(data) {
    const X = [];
    for (let i = 0; i < data.length; i++) {
        const { x } = data[i];
        const row = [
            1,
            x,
            Math.pow(x, 2),
            Math.pow(x, 3),
            ...getAllXs(data).map((x_k) => Math.pow(pos(x - x_k), 3)),
        ];
        X.push(row);
    }
    return matrix(X);
}
function mult(firstMatrix, ...matrices) {
    return matrices.reduce((runningProduct, matrix) => multiply(runningProduct, matrix), firstMatrix);
}
function solveForBetas(data, lambda) {
    const X = createBasisMatrix(data);
    const y = transpose(matrix(getAllYs(data)));
    const Xtrans = transpose(X);
    const numOfColsOfX = X.size()[1];
    const inner = add(multiply(Xtrans, X), multiply(lambda, identity(numOfColsOfX)));
    const invInner = inv(inner);
    const betas = mult(invInner, Xtrans, y);
    return betas;
}
function createBasisColVector(x, allXs) {
    return transpose(matrix([1, x, Math.pow(x, 2), Math.pow(x, 3), ...allXs.map((x_k) => Math.pow(pos(x - x_k), 3))]));
}
function generateSplinePoints(splineFn, data) {
    const splinePoints = [];
    const minX = Math.min(...getAllXs(data));
    const maxX = Math.max(...getAllXs(data));
    const stepSize = (maxX - minX) / 1000;
    for (let i = minX; i <= maxX; i += stepSize) {
        splinePoints.push({ x: i, y: splineFn(i) });
    }
    return splinePoints;
}
export default function smoothingSpline(data, { lambda = 1000 } = {}) {
    if (lambda <= 0) {
        throw new InvalidLambdaError("lambda must be greater than 0");
    }
    const betas = solveForBetas(data, lambda);
    const splineFn = (x) => {
        const result = multiply(betas, createBasisColVector(x, getAllXs(data)));
        return result;
    };
    const splinePoints = generateSplinePoints(splineFn, data);
    return {
        fn: splineFn,
        points: splinePoints,
    };
}
//# sourceMappingURL=index.js.map